[
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/captchas/",
	"title": "Captchas",
	"tags": [],
	"description": "",
	"content": "CAPTCHA es la abreviatura de Completely Automated Public Turing test to tell Computers and Humans Apart o en español Prueba de Turing Completamente Automática y Pública para diferenciar Ordenadores de Humanos, está explícitamente diseñado para prevenir la automatización, ¡así que no intentes automatizarlo!\nExisten dos estrategias principales para evitar los CAPTCHAs:\n Deshabilitar los CAPTCHAs en tus entornos de pruebas. Agrega un parámetro que permita que las pruebas hagan un baipás.  "
},
{
	"uri": "https://selenium.dev/documentation/es/front_matter/copyright_and_attributions/",
	"title": "Derechos de autor y atribuciones",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n The Documentation of Selenium Copyright \u0026copy; 2013-2020 , Software Freedom Conservancy.\nEvery effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book. No patent liability is assumed with respect to the use of the information contained herein.\nAttributions Thanks to: Selenium Main Repository .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @shs96c4482 commits \n@barancev2898 commits \n@jimevans2292 commits \n@jleyba1464 commits \n@jarib1298 commits \n@dfabulich1175 commits \n@illicitonion1162 commits \n@AutomatedTester799 commits \n@lukeis599 commits \n@eranmes473 commits \n@p0deje338 commits \n@mdub326 commits \n@titusfortner325 commits \n@andreastt289 commits \n@krosenvold225 commits \n@hugs205 commits \n@davehunt200 commits \n@hbchai191 commits \n@lmtierney179 commits \n@ph7147 commits \n@freynaud138 commits \n@samitbadle137 commits \n@nirvdrum133 commits \n@sevaseva115 commits \n@gigix109 commits \n@juangj108 commits \n@aslakhellesoy94 commits \n@alex-savchuk90 commits \n@andrashatvani66 commits \n@ajayk63 commits \n@twalpole49 commits \n@asashour48 commits \n@mikemelia46 commits \n@jherault44 commits \n@tebeka44 commits \n@santiycr41 commits \n@diemol38 commits \n@luke-hill37 commits \n@mach636 commits \n@ddavison31 commits \n@joshbruning30 commits \n@mikebroberts28 commits \n@JohnChen022 commits \n@valfirst22 commits \n@bret20 commits \n@cgoldberg20 commits \n@by-example19 commits \n@corevo17 commits \n@rbri16 commits \n@Harsha50915 commits \n@alb-i98615 commits \n@krmahadevan14 commits \n@bayandin12 commits \n@carlosgcampos12 commits \n@jayakumarc12 commits \n@43081j11 commits \n@detro10 commits \n@josephg10 commits \n@redsquirrel9 commits \n@RustyNail9 commits \n@InstyleVII8 commits \n@tourdedave8 commits \n@glib-briia7 commits \n@llaskin7 commits \n@DrMarcII7 commits \n@mmerrell7 commits \n@User2534897 commits \n@dratler7 commits \n@dima-groupon6 commits \n@nikolas6 commits \n@bwalderman5 commits \n@Herst5 commits \n@Dude-X5 commits \n@jimvm5 commits \n@JohanLorenzo5 commits \n@oddui5 commits \n@adiohana5 commits \n@Zitrax4 commits \n@dbo4 commits \n@xaircore4 commits \n@sangaline4 commits \n@Ardesco4 commits \n@klepikov4 commits \n@tobli4 commits \n@yizeng4 commits \n@abotalov4 commits \n@dylanlive4 commits \n@JasnoWa4 commits \n@mcharsley4 commits \n@GQAssurance4 commits \n@mojwang4 commits \n@alexhenrie3 commits \n@chrisblock3 commits \n@Marketionist3 commits \n@epall3 commits \n@thorn03 commits \n@johnjbarton3 commits \n@zch3 commits \n@zcmgyu3 commits \n@Dominator0083 commits \n\nSelenium IDE .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @corevo2445 commits \n@tourdedave610 commits \n@baimao843788 commits \n@Jongkeun51 commits \n@petermouse36 commits \n@LinYunWen36 commits \n@zavelevsky34 commits \n@xdennisx15 commits \n@dvd9006 commits \n@manoj97883 commits \n@shs96c3 commits \n@zewa6663 commits \n@diemol2 commits \n@lukeis2 commits \n@Meir0172 commits \n@toshiya2 commits \n@amitzur1 commits \n@aplorenzen1 commits \n@AutomatedTester1 commits \n@p26351 commits \n@avoid3d1 commits \n@sotayamashita1 commits \n@samitbadle1 commits \n@swes11171 commits \n@vivrichards6001 commits \n@bolasblack1 commits \n@dependabot[bot]1 commits \n@peter-kehl1 commits \n\nDocker Selenium .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @diemol212 commits \n@ddavison133 commits \n@mtscout653 commits \n@kayabendroth50 commits \n@elgalu24 commits \n@WillAbides8 commits \n@marten-cz5 commits \n@MacCracken5 commits \n@jsa345 commits \n@garagepoort4 commits \n@METAJIJI4 commits \n@manoj97884 commits \n@ZainabSalameh4 commits \n@vasikarla4 commits \n@chenrui3334 commits \n@niQo4 commits \n@testphreak4 commits \n@Remi-p3 commits \n@tnguyen143 commits \n@alexgibson3 commits \n@jeff-jk3 commits \n@pabloFuente3 commits \n@chuckg2 commits \n@davehunt2 commits \n@ehbello2 commits \n@glib-briia2 commits \n@joaoluizjoaquim2 commits \n@mathieu-pousse2 commits \n@phensley2 commits \n@ryneeverett2 commits \n@wheleph2 commits \n@schmunk422 commits \n@a-k-g1 commits \n@alexkogon1 commits \n@deviantintegral1 commits \n@anto-ac1 commits \n@eez01 commits \n@cben1 commits \n@Grisu1181 commits \n@gensc0041 commits \n@budtmo1 commits \n@charford1 commits \n@cyrille-leclerc1 commits \n@deiwin1 commits \n@enolan1 commits \n@evertones1 commits \n@hnryjms1 commits \n@doublemarket1 commits \n@hazmeister1 commits \n@McGriddle1 commits \n@jamesottaway1 commits \n@jarspi1 commits \n@BeyondEvil1 commits \n@ja8zyjits1 commits \n@jwhitlock1 commits \n@jonaseicher1 commits \n@CaffeinatedCM1 commits \n@karel19801 commits \n@kmala1 commits \n@lcnja1 commits \n@lmtierney1 commits \n@lukeis1 commits \n@m15o1 commits \n@michallepicki1 commits \n@mikewrighton1 commits \n@meeroslaph1 commits \n@nicolaiparlog1 commits \n@double161 commits \n@reinholdfuereder1 commits \n@remcorakers1 commits \n@rjatkins1 commits \n@scottturley1 commits \n@sethuster1 commits \n@smccarthy1 commits \n@stigkj1 commits \n@tadashi07131 commits \n@gitter-badger1 commits \n@graingert1 commits \n@ThomasMeschke1 commits \n@cvakiitho1 commits \n@torstenwalter1 commits \n@victor-catalyst1 commits \n@vv-p1 commits \n@wesmcouch1 commits \n@reegnz1 commits \n@eitany1 commits \n@miyajan1 commits \n@mgingras1 commits \n@mirkotschaeni1 commits \n@mkrei1 commits \n@neben1 commits \n@oleg-filiutsich1 commits \n@pujan141 commits \n@kinjelom1 commits \n\nSelenium Website \u0026amp; Docs .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @selenium-ci249 commits \n@diemol163 commits \n@Harsha509153 commits \n@alaahong39 commits \n@alenros28 commits \n@AlexAndradeSan25 commits \n@kzhirata20 commits \n@boris77917 commits \n@jmartinezpoq17 commits \n@manoj978813 commits \n@hiroksarker10 commits \n@ivanrodjr9 commits \n@liushilive6 commits \n@hyanx5 commits \n@barancev4 commits \n@ArCiGo3 commits \n@Madh933 commits \n@takeya0x863 commits \n@cambiph3 commits \n@lvninety3 commits \n@twinstae3 commits \n@Bredda2 commits \n@bongosway2 commits \n@kapilyadav12042 commits \n@palotas2 commits \n@miekof2 commits \n@natanportilho2 commits \n@rahuljhakant2 commits \n@urig2 commits \n@ilhanoztozlu2 commits \n@imba-tjd2 commits \n@0420syj2 commits \n@k198107032 commits \n@abhishek-malani1 commits \n@adithyab941 commits \n@vinogradoff1 commits \n@cjayswal1 commits \n@fastrde1 commits \n@f97gujo1 commits \n@bisforum1 commits \n@misiekofski1 commits \n@muditlambda1 commits \n@nikhil-lambda1 commits \n@TheTestLynx1 commits \n@MindScriptAct1 commits \n@sergey-oplavin1 commits \n@shs96c1 commits \n@thiagola921 commits \n@Ymangz1 commits \n@YoshikiIto1 commits \n@9484624481 commits \n@nadvolod1 commits \n@sangheon43531 commits \n@yingyingshang1 commits \n\nPrevious Selenium Website .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @lukeis417 commits \n@shs96c91 commits \n@tourdedave89 commits \n@pgrandje79 commits \n@barancev63 commits \n@lightbody59 commits \n@ajayk40 commits \n@tarun3kumar40 commits \n@ddavison36 commits \n@davehunt26 commits \n@manoj978824 commits \n@peter-kehl22 commits \n@lmtierney21 commits \n@samitbadle21 commits \n@santiycr19 commits \n@illicitonion17 commits \n@pnewhook14 commits \n@AutomatedTester12 commits \n@rasmusbergpalm11 commits \n@juangj11 commits \n@lukeis-sfdc10 commits \n@andreastt7 commits \n@hugs6 commits \n@jarib5 commits \n@jimevans5 commits \n@llaskin5 commits \n@PaulKC5 commits \n@titusfortner5 commits \n@corevo5 commits \n@diemol3 commits \n@asashour2 commits \n@oleksandr-lobunets2 commits \n@alex-savchuk2 commits \n@javabrett2 commits \n@darrincherry2 commits \n@eranmes2 commits \n@hazmeister2 commits \n@julianharty2 commits \n@mikemelia2 commits \n@paul-hammant2 commits \n@labkey-tchad2 commits \n@abhijain26182 commits \n@agabrys1 commits \n@azawawi1 commits \n@alb-i9861 commits \n@hollingsworthd1 commits \n@dylans1 commits \n@EmidioStani1 commits \n@FagnerMartinsBrack1 commits \n@Xaeroxe1 commits \n@JamesZoft1 commits \n@jleyba1 commits \n@JasnoWa1 commits \n@JustAGuyTryingToCodeSomething1 commits \n@kdamball1 commits \n@laurin11 commits \n@klamping1 commits \n@krmahadevan1 commits \n@krosenvold1 commits \n@mmerrell1 commits \n@grawk1 commits \n@mcavigelli1 commits \n@michaelwowro1 commits \n@muralidharand1 commits \n@meeroslaph1 commits \n@NickAb1 commits \n@ohadschn1 commits \n@oifland1 commits \n@rbri1 commits \n@roydekleijn1 commits \n@QuinnWilton1 commits \n@smatei1 commits \n@harrissAvalon1 commits \n@stevedesmond-ca1 commits \n@Vimal-N1 commits \n@yasinguzel1 commits \n@tobecrazy1 commits \n@Zearin1 commits \n@beckendorff1 commits \n@daveOrleans1 commits \n@androiddriver1 commits \n@mauk811 commits \n@pharry221 commits \n@prab21121 commits \n@refactoror1 commits \n@rogerdc1 commits \n@tibord1 commits \n@ygmarchi1 commits \n\nPrevious Documentation Rewrite Project .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @andreastt197 commits \n@selenium-ci105 commits \n@diemol54 commits \n@hazmeister30 commits \n@santiycr27 commits \n@AlexAndradeSan25 commits \n@lukeis21 commits \n@Harsha50917 commits \n@ddavison16 commits \n@davehunt12 commits \n@manoj978812 commits \n@orieken12 commits \n@djangofan12 commits \n@liushilive8 commits \n@User2534897 commits \n@jimholmes6 commits \n@imba-tjd6 commits \n@mmerrell6 commits \n@shs96c6 commits \n@picimako5 commits \n@vijay445 commits \n@cambiph5 commits \n@nvonop4 commits \n@rivlinp4 commits \n@sheg4 commits \n@bizob28284 commits \n@detro3 commits \n@Ardesco3 commits \n@TheTestLynx3 commits \n@boris7792 commits \n@Bredda2 commits \n@juperala2 commits \n@lmtierney2 commits \n@systemboogie2 commits \n@palotas2 commits \n@miekof2 commits \n@sri852 commits \n@hoanluu2 commits \n@ilhanoztozlu2 commits \n@paul-barton2 commits \n@adithyab941 commits \n@alenros1 commits \n@p0deje1 commits \n@AJ-721 commits \n@abotalov1 commits \n@bhardin1 commits \n@chamiz1 commits \n@dennybiasiolli1 commits \n@donhuvy1 commits \n@bongosway1 commits \n@nicegraham1 commits \n@f97gujo1 commits \n@JakimLi1 commits \n@austenjt1 commits \n@kmcgon1 commits \n@MartinDelille1 commits \n@michael-coleman1 commits \n@misiekofski1 commits \n@MilanMasek1 commits \n@rakib-amin1 commits \n@NRezek1 commits \n@nikai3d1 commits \n@OndraM1 commits \n@sourabhkt1 commits \n@whhone1 commits \n@yarix1 commits \n@ZbigniewZabost1 commits \n@agmen1 commits \n@hking-shutterfly1 commits \n@jimevans1 commits \n@9484624481 commits \n@marilyn1 commits \n@riccione1 commits \n@tungla1 commits \n@zeljkofilipin1 commits \n\nThird-Party software used by Selenium documentation project:    Software Version License     Hugo v0.59.0 Apache 2.0   Hugo Learn Theme v2.4.0 MIT   Code Tabs Style \u0026mdash; MIT    License All code and documentation originating from the Selenium project is licensed under the Apache 2.0 license, with the Software Freedom Conservancy as the copyright holder.\nThe license is included here for convenience, but you can also find it on the Apache Foundation\u0026rsquo;s websites:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/the_selenium_project_and_tools/",
	"title": "El proyecto Selenium y sus herramientas",
	"tags": [],
	"description": "",
	"content": " Selenium controla los navegadores web Selenium significa muchas cosas pero en su núcleo, es un conjunto de herramientas para la automatización de navegadores web que utiliza las mejores técnicas disponibles para controlar remotamente las instancias de los navegadores y emular la interacción del usuario con el navegador.\nPermite a los usuarios simular interacciones básicas realizadas por los usuarios finales; insertando texto en los campos, seleccionando valores de menús desplegables y casillas de verificación, y haciendo clics en los enlaces de los documentos. También provee muchos otros controles tales como el movimiento del mouse, la ejecución arbitraria de JavaScript, y mucho más.\nA pesar de que es usado principalmente para pruebas de front-end de sitios webs, Selenium es en esencia una librería de agente de usuario para el navegador. Las interfaces son ubicuas a su aplicación, lo que fomenta la composición con otras librerías para adaptarse a su propósito.\nUna interfaz para gobernarlos a todos Uno de los principios fundamentales del proyecto es permitir una interfaz común para todas las tecnologías de los (principales) navegadores. Los navegadores web son aplicaciones increíblemente complejas y de mucha ingeniería, realizando operaciones completamente diferentes pero que usualmente se ven iguales al hacerlo. Aunque el texto se presente con las mismas fuentes, las imágenes se muestren en el mismo lugar y los enlaces te llevan al mismo destino. Lo que sucede por debajo es tan diferente como la noche y el día. Selenium abstrae estas diferencias, ocultando sus detalles y complejidades a la persona que escribe el código. Esto le permite escribir varias líneas de código para realizar un flujo de trabajo complicado, pero estas mismas líneas se ejecutarán en Firefox, Internet Explorer, Chrome y los demás navegadores compatibles.\nHerramientas y soporte El diseño minimalista de Selenium le da la versatilidad para que se pueda incluir como un componente en otras aplicaciones. La infraestructura proporcionada debajo del catálogo de Selenium te da las herramientas para que puedas ensamblar tu grid de navegadores de modo que tus pruebas se puedan ejecutar en diferentes navegadores a través de diferente sistemas operativos y plataformas.\nImagina un banco de computadores en tu sala de servidores o en un centro de datos, todos ejecutando navegadores al mismo tiempo e interactuando con los enlaces en tu sitio web, formularios, y tablas\u0026mdash;probando tu aplicación 24 horas al día. A través de la sencilla interfaz de programación proporcionada para los lenguajes más comunes, estas pruebas se ejecutarán incansablemente en paralelo, reportando cuando ocurran errores.\nEs un objetivo ayudar a que esto sea una realidad para ti, proporcionando a los usuarios herramientas y documentación para controlar no solo los navegadores pero también para facilitar la escalabilidad e implementación de tales grids.\nQuien utiliza Selenium Muchas de las empresas más importantes del mundo han adoptado Selenium para sus pruebas basadas en navegador, a menudo reemplazando esfuerzos de años que involucran otras herramientas propietarias. A medida que ha crecido en popularidad, también se han multiplicado sus requisitos y desafíos.\nA medida que la web se vuelve más complicada y se agregan nuevas tecnologías a los sitios web, la misión de este proyecto es mantenerse al día con ellos siempre que sea posible. Siendo un proyecto de código abierto, este apoyo se sustenta a través de la donación generosa de tiempo de muchos voluntarios, cada uno de los cuales tiene un \u0026ldquo;trabajo diurno\u0026rdquo;.\nOtra misión del proyecto es alentar a más voluntarios a participar en este esfuerzo, y construir una comunidad fuerte para que el proyecto pueda seguir el ritmo de las tecnologías emergentes y seguir siendo una plataforma dominante para la automatización de pruebas funcionales.\nHistoria Cuando Selenium 1 fue lanzado en el año 2004, surgió por la necesidad de reducir el tiempo dedicado a verificar manualmente el comportamiento consistente en el front-end de una aplicación web. Hizo uso de las herramientas disponibles en ese momento y confió en gran medida en la inyección de JavaScript en la página web bajo prueba para emular la interacción de un usuario.\nSi bien JavaScript es una buena herramienta para permitirte la introspección de las propiedades del DOM y para hacer ciertas observaciones del lado del cliente que de otro modo no se podría hacer, se queda corto en la capacidad de replicar naturalmente las interacciones de un usuario como usar el mouse y el teclado.\nDesde entonces, Selenium ha crecido y ha madurado bastante, convirtiéndose en una herramienta ampliamente utilizada por muchas\u0026mdash;o sino por la mayoría\u0026mdash; de las organizaciones más grandes del mundo. Selenium ha pasado de ser de un kit de herramientas de automatización de pruebas de fabricación casera desarrollado en Thoughtworks para un público específico y un caso de uso específico, a la librería de facto de automatización de navegadores del mundo.\nAsí como Selenium RC hizo uso de las herramientas de oficio disponibles en ese momento, Selenium WebDriver impulsa esta tradición al llevar la parte de la interacción del navegador al territorio del proveedor del mismo y pedirles que se responsabilicen de las implementaciones de back-end orientadas al navegador. Recientemente este esfuerzo se ha convertido en un proceso de estandarización del W3C donde el objetivo es convertir el componente WebDriver en Selenium en la librería de control remoto du jour para agentes de usuario.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started/",
	"title": "Empezando",
	"tags": [],
	"description": "",
	"content": " Empezando Si eres nuevo con Selenium, tenemos una serie de recursos que te pueden ayudar a ponerte al día de inmediato\n Tour rápido  WebDriver IDE Grid   "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/understanding_the_components/",
	"title": "Entendiendo los componentes",
	"tags": [],
	"description": "",
	"content": " Construir una suite de test usando WebDriver requerirá que entiendas y uses de forma efectiva diferentes componentes. Como con todo en el desarrollo de software, la gente usa diferentes términos para la misma idea. A continuación hay un desglose de cómo los términos son usados en esa descripción.\nTerminología  API: Interfaz de Programación de Aplicaciones. Es un conjunto de \u0026ldquo;comandos\u0026rdquo; que se utilizan para manipular el WebDriver. Library: Un módulo de código que contiene las APIs y el código necesario para implementarlos. Las librerías son específicas para cada lenguaje, por ejemplo ficheros .jar en Java, ficheros .dll para .NET, etc. Driver: El responsable de controlar el navegador actual. La mayoría de los drivers son creados por los vendors del navegador. Los Drivers son generalmente módulos ejecutables que corren en el sistema con el propio navegador, no en el sistema ejecutando la suite de test. (Aunque esos pueden ser el mismo sistema.) NOTE: Algunas personas se refieren a los drivers como proxies. Framework: Una librería adicional usada como un soporte para la suites de WebDriver. Estos frameworks pueden ser test frameworks como JUnit o NUnit. También pueden ser frameworks soportando lenguaje natural como Cucumber o Robotium. Los frameworks también pueden ser escritos y usados para cosas como la manipulación o configuración del sistema bajo la prueba, creación de datos, test oracles, etc  Las Partes y las Piezas Como mínimo, el WebDriver habla con un navegador a través del driver. La comunicación es bidireccional: el WebDriver pasa comandos al navegador a través del driver, y recive la información de vuelta por la misma ruta.\nEl driver es específico para el navegador, como es ChromeDriver para Chrome/Chromium de Google, GeckoDriver para Mozilla Firefox, etc. El driver corre en el mismo sistema que el browser. Esto puede, o no puede ser, el mismo sistema donde los tests se están ejecutando.\nEste simple ejemplo anterior es de comunicación directa. La comunicación con el navegador puede ser remota a través de Selenium Server o RemoteWebdriver. Éste último corre en el mismo sistema que el driver y el browser.\nLa comunicación remota puede también hacerse usando Selenium Server o Selenium Grid, ambos a su vez hablan con el driver en el sistema anfitrión.\nDónde encaja el Framework El WebDriver tiene un trabajo y solo un trabajo: comunicarse con el navegador a través de uno de los métodos nombrados. El WebDriver no tiene que saber nada sobre testing: no sabe cómo comparar cosas, asegurar un pass o fail, y ciertamente no sabe nada acerca de reportes o sobre la gramática Given/When/Then.\nAquí es donde varios frameworks entran en juego. Como mínimo neesitarás un framework de test que compare los enlaces de idiomas, por ejempolo NUnit para .NET, JUnit para Java, RSpec para Ruby, etc.\nEl framework de test es responsable de correr y ejecutar tu WebDriver y los pasos de tus tests. Como tal, puedes pensar que se parece a la siguiente imagen.\nLos frameworks o herramientas de lenguage natural como Cucumber pueden existir como parte de la caja de Test Framework de la figura de arriba, o envolver totalmente el Test Framework en su propia implementación.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started/quick/",
	"title": "Guía rápida",
	"tags": [],
	"description": "",
	"content": " Selenium no es solo una herramienta o API, sino que compone muchas herramientas.\nWebDriver Si está comenzando con la automatización de pruebas de sitios web de escritorio, entonces va a utilizar las API de WebDriver. WebDriver utiliza las API de automatización del navegador proporcionadas por los desarrolladores de los navegadores para controlar el navegador y ejecutar pruebas. Esto es como si un usuario real estuviera manipulando el navegador. Dado que el WebDriver no requiere que su API se compile con el código de la aplicación que va a probar, no es de naturaleza intrusiva. Por lo tanto, está probando la misma aplicación que está en vivo.\nIDE IDE (Integrated Development Environment) es la herramienta que usas para desarrollar tus casos de prueba con Selenium. Es una extensión para Chrome y Firefox muy sencilla de usar y es generalmente la forma mas eficiente de desarrollar casos de prueba. Esta graba las acciones del usuario en el navegador, usando los comandos existentes en Selenium, con parámetros definidos por el contexto de cada elemento. No solo sirve para ahorrar tiempo sino que también es una forma excelente de aprender la sintaxis de scripts de Selenium.\nGrid Selenium Grid te permite ejecutar casos de prueba en diferentes maquinas a través de diferentes plataformas. La gestión que desencadena las ejecuciones de los casos de prueba se realiza en la parte local, y cuando los casos de prueba se hayan disparado, automáticamente serán ejecutados en la parte remota.\nPoco después del desarrollo de las pruebas de WebDriver, es posible que deba ejecutar sus pruebas en múltiples combinaciones de navegador y sistema operativo. Aquí es donde Grid viene al rescate.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/installing_selenium_libraries/",
	"title": "Instalando las librerías de Selenium",
	"tags": [],
	"description": "",
	"content": " Primero debes instalar las librerías de enlace Selenium para tu proyecto de automatización. El proceso de instalación de las librerías depende del lenguaje que elijas usar.\nJava La instalación de las librerías Selenium para Java se puede hacer usando Maven. Agrega la dependencia de selenium-java en el pom.xml de tu proyecto:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; La dependencia selenium-java permite la ejecución de tu proyecto de automatización en todos los navegadores compatibles con Selenium. Si quieres ejecutar pruebas en un navegador en específico, puedes agregar la dependencia para ese navegador en el archivo pom.xml. Por ejemplo, debes agregar la siguiente dependencia en tu archivo pom.xml para ejecutar tus pruebas solamente en Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De igual manera, si quieres ejecutar las pruebas solamente en Chrome, debes agregar la siguiente dependencia:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python La instalación de las librerías de Selenium en Python se puede hacer usando pip:\npip install selenium Alternativamente, puedes descargar el archivo fuente PyPI (selenium-x.x.x.tar.gz) e instalarlo usando setup.py:\npython setup.py install C# La instalación de las librerías de Selenium para C# se puede hacer usando NuGet:\n# Usando el manejador de paquetess Install-Package Selenium.WebDriver # o usando el CLI de .Net dotnet add package Selenium.WebDriver Ruby La instalación de las librerías de Selenium para Ruby se puede hacer usando gem:\ngem install selenium-webdriver JavaScript La instalación de las librerías de Selenium para JavaScript se puede hacer usando npm:\nnpm install selenium-webdriver Kotlin Debido a la falta de librerías de enlace de idioma nativas para Kotlin, debe usar las de Java, p. ej. con Maven Java\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/page_object_models/",
	"title": "Modelos de objetos de página",
	"tags": [],
	"description": "",
	"content": "Page Object (objeto de página) es un patrón de diseño que se ha vuelto popular en la automatización de pruebas para mejorar el mantenimiento de las pruebas y reducir la duplicación de código. Un objeto de página es un clase orientada a objetos que sirve como interfaz para una página de tu AUT. Las pruebas luego usan los métodos de esta clase de objeto de página cuando lo necesitan para interactuar con la interfaz de usuario de esa página. El beneficio es que si la interfaz de usuario cambia para la página, las pruebas en sí mismas no necesitan cambiar, solo el código dentro del objeto de página necesita cambiar. Posteriormente, todos los cambios para soportar esa nueva interfaz de usuario están ubicados en un solo lugar.\nEl patrón de diseño de objetos de página ofrece las siguientes ventajas:\n Existe una separación clara entre el código de prueba y el código específico de la página, como localizadores (o su uso si está utilizando un mapa de interfaz de usuario) y diseño. Existe un único repositorio para los servicios u operaciones que ofrece la página en lugar de tener estos servicios dispersos a lo largo de las pruebas.  En ambos casos, esto permite cualquier modificación requerida debido a cambios en la interfaz de usuario puedan hacerse en un solo lugar. Puedes encontrar buena información sobre esta técnica en numerosos blogs, ya que este \u0026ldquo;patrón de diseño de prueba\u0026rdquo; se está utilizando ampliamente. Nosotros animamos al lector que desea saber más a buscar blogs en Internet al respecto.\nMuchos han escrito sobre este patrón de diseño y pueden proporcionar consejos útiles más allá del alcance de esta guía del usuario. Para empezar, sin embargo, ilustraremos objetos de página con un ejemplo simple.\nPrimero, considere un ejemplo, típico de la automatización de pruebas, que no utiliza un objeto de página:\n/*** * Prueba de la funcionalidad de inicio de sesión */ public class Login { public void testLogin() { // ingresa los datos de inicio de sesión en la página de inicio de sesión  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // verifica que la etiqueta h1 tiene el valor \u0026#34;Hello userName\u0026#34; después de iniciar sesión  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } Hay dos problemas con este enfoque.\n No hay separación entre el método de prueba y los localizadores del AUT (ID en este ejemplo); ambos están entrelazados en un solo método. Si la UI del AUT cambia sus identificadores, diseño o cómo se ingresa y procesa un inicio de sesión, la prueba en sí debe cambiar. Los localizadores de ID se distribuirían en múltiples pruebas, en todas las pruebas que debían usar esta página de inicio de sesión.  Aplicando las técnicas de objeto de página, este ejemplo podría reescribirse como en el siguiente ejemplo de un objeto de página para una página de inicio de sesión.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * El objeto de página encapsula la página de inicio de sesión. */ public class SignInPage { protected static WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Inicia sesión como un usuario válido * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } y el objeto de página para una página de inicio podría verse así.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * El objeto de página encapsula la página de inicio */ public class HomePage { protected static WebDriver driver; // \u0026lt;h1\u0026gt;Hola userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Encapsulación de página para administrar la funcionalidad del perfil  return new HomePage(driver); } /* Mas métodos que ofrecen los servicios representados por la página de inicio del usuario registrado. Estos métodos a su vez podrían devolver más objetos de página, por ejemplo hacer clic en el botón Redactar correo podría devolver el objeto de clase ComposeMail */ } Entonces, la prueba de inicio de sesión usaría estos dos objetos de página de la siguiente manera.\n/*** * Prueba de la funcionalidad de inicio de sesión de pruebas */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } Hay mucha flexibilidad en cómo se pueden diseñar los objetos de página, pero hay algunas reglas básicas para obtener la mantenibilidad deseada de tu código de prueba.\nLos objetos de página en sí mismos nunca deben hacer verificaciones o afirmaciones. Esto es parte de tu prueba y siempre debe estar dentro del código de la prueba, nunca en una página objeto. El objeto de página contendrá la representación de la página, y el servicios que proporciona la página a través de métodos, pero ningún código relacionado con lo que se está probado debe estar dentro del objeto de la página.\nHay una verificación única que puede y debe estar dentro del objeto de página y eso es para verificar que la página, y posiblemente elementos críticos en la página, se cargaron correctamente. Esta verificación debe hacerse mientras se instancia el objeto de la página. En los ejemplos anteriores, tanto SignInPage como los constructores de HomePage verifican que la página esperada esté disponible y lista para las solicitudes de la prueba.\nUn objeto de página no necesariamente necesita representar una página completa. El patrón de diseño de objetos de pagina podría usarse para representar componentes en una página. Si la página en el AUT tiene múltiples componentes, puede mejorar la mantenibilidad si hay un objeto de página separado para cada componente.\nExisten otros patrones de diseño que también pueden usarse en las pruebas. Algunos usan un Page Factory para crear instancias de sus objetos de página. Discutir todo esto es más allá del alcance de esta guía del usuario. Aquí, simplemente queremos presentar los conceptos para que el lector tome conciencia de algunas de las cosas que se pueden hacer. Como fue mencionado anteriormente, muchos han blogueado sobre este tema y alentamos lector para buscar blogs sobre estos temas.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/browsers/",
	"title": "Navegadores",
	"tags": [],
	"description": "",
	"content": " Navegadores para el consumidor El framework de Selenium soporta oficialmente los siguientes navegadores:\n   Navegador Mantenedor Versiones Soportadas     Chrome Chromium Todas las Versiones   Firefox Mozilla 54 y más recientes   Internet Explorer Selenium 6 y más recientes   Opera Opera Chromium / Presto 10.5 y más recientes   Safari Apple 10 y más recientes    Navegadores especializados También hay un conjunto de navegadores especializados utilizados típicamente en entornos de desarrollo. Podemos utilizar algunos de estos navegadores para fines de automatización, y Selenium proporciona apoyo a los siguientes controladores especializados:\n   Nombre del Controlador Prepósito Mantenedor     HtmlUnitDriver Emulador de navegador headless respaldado por Rhino Proyecto Selenium    "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/purposes_and_main_functionalities/",
	"title": "Objetivos y funcionalidades principales",
	"tags": [],
	"description": "",
	"content": " Punto de entrada centralizado para todos los tests Gestión y control de los nodos / entornos donde se ejecutan los navegadores Escalado Ejecución de los tests en paralelo Testing cruzado entre diferentes sistemas operativos Balanceo de carga  "
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Introducción Selenium RC fue el principal proyecto de Selenium durante mucho tiempo, antes de que la union de WebDriver/Selenium resultaran en Selenium 2, una herramienta más poderosa. Vale la pena resaltar que Selenium 1 ya no es soportado.\nComo funciona Selenium RC Primero, describiremos cómo funcionan los componentes de Selenium RC y el papel que desempeña cada uno en la ejecución tus scripts de prueba.\nComponentes de RC Los componentes de Selenium RC son:\n El servidor Selenium que inicia y finaliza navegadores, interpreta y ejecuta los comandos Selenese pasados del programa de prueba, y actúa como un proxy HTTP, interceptando y verificando los mensajes HTTP pasados entre el navegador y el AUT. Librerías de clientes que proporcionan la interfaz entre cada lenguaje de programación y Selenium RC Server.  Aquí hay un diagrama simplificado de la arquitectura:\nEl diagrama muestra que las librerías del cliente se comunican con el el servidor pasando cada comando Selenium para su ejecución. Entonces el servidor pasa el comando Selenium al navegador utilizando los comandos JavaScript de Selenium-Core. El navegador, utilizando su intérprete de JavaScript, ejecuta el comando Selenium. Esta ejecuta la acción o verificación de Selenese que especificas en tu script de prueba.\nSelenium Server Selenium Server recibe comandos de Selenium de tu programa de prueba, los interpreta e informa a tu programa los resultados de ejecutar esas pruebas.\nEl servidor RC agrupa Selenium Core y automáticamente lo inyecta en el navegador. Esto ocurre cuando tu programa de prueba abre el navegador (utilizando una función del API de la librería del cliente). Selenium-Core es un programa de JavaScript, en realidad un conjunto de funciones JavaScript que interpretan y ejecutan comandos Selenese utilizando el intérprete de JavaScript incorporado en el navegador.\nEl servidor recibe los comandos Selenese de tu programa de prueba utilizando simples solicitudes HTTP GET/POST. Esto significa que puedes usar cualquier lenguaje de programación que pueda enviar solicitudes HTTP para automatizar pruebas de Selenium en el navegador.\nLibrerías de Clientes Las librerías del cliente proporcionan el soporte de programación que te permiten ejecutar comandos Selenium desde un programa de tu propio diseño. Hay una librería cliente diferente para cada lenguaje compatible. Una librería cliente de Selenium proporciona una interfaz de programación (API), es decir, un conjunto de funciones, que ejecuta comandos de Selenium desde tu propio programa. Dentro de cada interfaz, hay una función de programación que soporta cada comando de Selenese.\nLa librería del cliente toma un comando Selenese y lo pasa al servidor Selenium para procesar una acción o prueba específica contra la aplicación bajo prueba (AUT). La librería del cliente también recibe el resultado de ese comando y lo devuelve a tu programa. Tu programa puede recibir el resultado y almacenarlo en una variable del programa e informarlo como un éxito o un fracaso, o posiblemente tomar medidas correctivas si fue un error inesperado.\nEntonces, para crear un programa de prueba, simplemente escribe un programa que ejecute un conjunto de comandos de Selenium utilizando una API de la librería del cliente. Y, opcionalmente, si ya tienes un script de prueba Selenese creado en Selenium-IDE, puedes generar el código Selenium RC. Selenium-IDE puede traducir (utilizando los elementos del menú Exportar) tus comandos Selenium en las llamadas a la función API de un cliente-controlador. Consulta el capítulo Selenium-IDE para obtener información específica sobre la exportación de código RC de Selenium-IDE.\nInstalación La instalación es más bien un nombre inapropiado para Selenium. Selenium tiene un conjunto de librerías disponibles en el lenguaje de programación que elijas. Puedes descargarlos desde la pagina de descarga.\nUna vez que hayas elegido un lenguaje para trabajar, simplemente necesitas:\n Instalar el servidor Selenium RC. Configurar un proyecto de programación utilizando un controlador de cliente específico del lenguaje.  Instalando Selenium Server El servidor Selenium RC es simplemente un archivo Java jar (selenium-server-standalone-.jar), que no requiere una instalación especial. Simplemente descargando el archivo zip y extrayendo el servidor en el directorio deseado es suficiente.\nEjecutando Selenium Server Antes de comenzar cualquier prueba, debes iniciar el servidor. Ve al directorio donde se encuentra el servidor de Selenium RC y ejecuta lo siguiente desde una consola línea de comandos.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar Esto se puede simplificar creando un archivo ejecutable batch o shell (.bat en Windows y .sh en Linux) que contiene el comando anterior. Luego haz un acceso directo a ese ejecutable en tu escritorio y simplemente haz doble clic en el icono para iniciar el servidor.\nPara que el servidor se ejecute, necesitarás Java instalado y la variable de entorno PATH configurada correctamente para ejecutarla desde la consola. Puedes verificar que tienes Java instalado correctamente ejecutando lo siguiente en una consola\njava -version Si obtienes un número de versión (que debe ser 1.5 o posterior), estás listo para comenzar a usar Selenium RC.\nUtilizando el controlador de cliente Java  Descarga el zip del controlador del cliente Java de Selenium desde SeleniumHQ página de descargas. Extrae el archivo selenium-java-.jar Abra tu IDE de Java deseado (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Crea un proyecto java. Agregaa los archivos selenium-java-.jar a tu proyecto como referencias. Agrega a tu classpath de proyecto el archivo selenium-java-jar. Desde Selenium-IDE, exporta un script a un archivo Java e inclúyelo en tu proyecto Java, o escribe tu prueba de Selenium en Java usando la API selenium-java-client. La API se presenta más adelante en este capítulo. Puedes usar JUnit o TestNg para ejecutar tu prueba, o puedes escribir tu propio programa main() simple. Estos conceptos son explicados más adelante en esta sección. Ejecuta el servidor Selenium desde la consola. Ejecuta tu prueba desde el IDE de Java o desde la línea de comandos.  Para obtener detalles sobre la configuración del proyecto de prueba Java, consulta las secciones del Apéndice: Configuración de Selenium RC con Eclipse y Configuración de Selenium RC con IntelliJ.\nUtilizando el controlador de cliente Python  Instala Selenium via PIP, las instrucciones están en SeleniumHQ pagina de descargas Escribe tu prueba de Selenium en Python o exporta un script de Selenium-IDE a un archivo de Python. Ejecuta el servidor Selenium desde la consola. Ejecuta tu prueba desde una consola o tu IDE de Python.  Para obtener detalles sobre la configuración del controlador del cliente Python, consulte el Apéndice: Configuración del controlador del cliente Python.\nUsing the .NET Client Driver  Download Selenium RC from the SeleniumHQ downloads page Extract the folder Download and install NUnit ( Note: You can use NUnit as your test engine. If you\u0026rsquo;re not familiar yet with NUnit, you can also write a simple main() function to run your tests; however NUnit is very useful as a test engine.) Open your desired .Net IDE (Visual Studio, SharpDevelop, MonoDevelop) Create a class library (.dll) Add references to the following DLLs: nmock.dll, nunit.core.dll, nunit. framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll and ThoughtWorks.Selenium.UnitTests.dll Write your Selenium test in a .Net language (C#, VB.Net), or export a script from Selenium-IDE to a C# file and copy this code into the class file you just created. Write your own simple main() program or you can include NUnit in your project for running your test. These concepts are explained later in this chapter. Run Selenium server from console Run your test either from the IDE, from the NUnit GUI or from the command line  For specific details on .NET client driver configuration with Visual Studio, see the appendix .NET client driver configuration.\nUsing the Ruby Client Driver  If you do not already have RubyGems, install it from RubyForge. Run gem install selenium-client At the top of your test script, add require \u0026quot;selenium/client\u0026quot; Write your test script using any Ruby test harness (eg Test::Unit, Mini::Test or RSpec). Run Selenium RC server from the console. Execute your test in the same way you would run any other Ruby script.  For details on Ruby client driver configuration, see the Selenium-Client documentation_\nFrom Selenese to a Program The primary task for using Selenium RC is to convert your Selenese into a programming language. In this section, we provide several different language-specific examples.\nSample Test Script Let\u0026rsquo;s start with an example Selenese test script. Imagine recording the following test with Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Note: This example would work with the Google search page http://www.google.com\nSelenese as Programming Code Here is the test script exported (via Selenium-IDE) to each of the supported programming languages. If you have at least basic knowledge of an object- oriented programming language, you will understand how Selenium runs Selenese commands by reading one of these examples. To see an example in a specific language, select one of these buttons.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } }  Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt;  Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end In the next section we\u0026rsquo;ll explain how to build a test program using the generated code.\nProgramming Your Test Now we\u0026rsquo;ll illustrate how to program your own tests using examples in each of the supported programming languages. There are essentially two tasks:\n Generate your script into a programming language from Selenium-IDE, optionally modifying the result.\n Write a very simple main program that executes the generated code.\n  Optionally, you can adopt a test engine platform like JUnit or TestNG for Java, or NUnit for .NET if you are using one of those languages.\nHere, we show language-specific examples. The language-specific APIs tend to differ from one to another, so you\u0026rsquo;ll find a separate explanation for each.\n Java C# Python Ruby Perl, PHP  Java For Java, people use either JUnit or TestNG as the test engine.\nSome development environments like Eclipse have direct support for these via plug-ins. This makes it even easier. Teaching JUnit or TestNG is beyond the scope of this document however materials may be found online and there are publications available. If you are already a \u0026ldquo;java-shop\u0026rdquo; chances are your developers will already have some experience with one of these test frameworks.\nYou will probably want to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The Selenium-IDE generated code will look like this. This example has comments added manually for additional clarity.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# The .NET Client Driver works with Microsoft.NET. It can be used with any .NET testing framework like NUnit or the Visual Studio 2005 Team System.\nSelenium-IDE assumes you will use NUnit as your testing framework. You can see this in the generated code below. It includes the using statement for NUnit along with corresponding NUnit attributes identifying the role for each member function of the test class.\nYou will probably have to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;);  The generated code will look similar to this.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } }  You can allow NUnit to manage the execution of your tests. Or alternatively, you can write a simple main() program that instantiates the test object and runs each of the three methods, SetupTest(), TheNewTest(), and TeardownTest() in turn.\nPython Pyunit is the test framework to use for Python.\nThe basic test structure is:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Old (pre 2.0) versions of Selenium-IDE generate Ruby code that requires the old Selenium gem. Therefore, it is advisable to update any Ruby scripts generated by the IDE as follows:\n On line 1, change require \u0026quot;selenium\u0026quot; to require \u0026quot;selenium/client\u0026quot;\n On line 11, change Selenium::SeleniumDriver.new to Selenium::Client::Driver.new\n  You probably also want to change the class name to something more informative than \u0026ldquo;Untitled,\u0026rdquo; and change the test method\u0026rsquo;s name to something other than \u0026ldquo;test_untitled.\u0026rdquo;\nHere is a simple example created by modifying the Ruby code generated by Selenium IDE, as described above.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP The members of the documentation team have not used Selenium RC with Perl or PHP. If you are using Selenium RC with either of these two languages please contact the Documentation Team (see the chapter on contributing). We would love to include some examples from you and your experiences, to support Perl and PHP users.\nLearning the API The Selenium RC API uses naming conventions that, assuming you understand Selenese, much of the interface\nwill be self-explanatory. Here, however, we explain the most critical and possibly less obvious aspects.\nStarting the Browser CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start();  Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Each of these examples opens the browser and represents that browser by assigning a \u0026ldquo;browser instance\u0026rdquo; to a program variable. This program variable is then used to call methods from the browser. These methods execute the Selenium commands, i.e. like open or type or the verify commands.\nThe parameters required when creating the browser instance are:\n host Specifies the IP address of the computer where the server is located. Usually, this is the same machine as where the client is running, so in this case localhost is passed. In some clients this is an optional parameter.\n port Specifies the TCP/IP socket where the server is listening waiting for the client to establish a connection. This also is optional in some client drivers.\n browser The browser in which you want to run the tests. This is a required parameter.\n url The base url of the application under test. This is required by all the client libs and is integral information for starting up the browser-proxy-AUT communication.\n  Note that some of the client libraries require the browser to be started explicitly by calling its start() method.\nRunning Commands Once you have the browser initialized and assigned to a variable (generally named \u0026ldquo;selenium\u0026rdquo;) you can make it run Selenese commands by calling the respective methods from the browser variable. For example, to call the type method of the selenium object:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) In the background the browser will actually perform a type operation, essentially identical to a user typing input into the browser, by\nusing the locator and the string you specified during the method call.\nReporting Results Selenium RC does not have its own mechanism for reporting results. Rather, it allows you to build your reporting customized to your needs using features of your chosen programming language. That\u0026rsquo;s great, but what if you simply want something quick that\u0026rsquo;s already done for you? Often an existing library or test framework can meet your needs faster than developing your own test reporting code.\nTest Framework Reporting Tools Test frameworks are available for many programming languages. These, along with their primary function of providing a flexible test engine for executing your tests, include library code for reporting results. For example, Java has two commonly used test frameworks, JUnit and TestNG. .NET also has its own, NUnit.\nWe won\u0026rsquo;t teach the frameworks themselves here; that\u0026rsquo;s beyond the scope of this user guide. We will simply introduce the framework features that relate to Selenium along with some techniques you can apply. There are good books available on these test frameworks however along with information on the internet.\nTest Report Libraries Also available are third-party libraries specifically created for reporting test results in your chosen programming language. These often support a variety of formats such as HTML or PDF.\nWhat\u0026rsquo;s The Best Approach? Most people new to the testing frameworks will begin with the framework\u0026rsquo;s built-in reporting features. From there most will examine any available libraries as that\u0026rsquo;s less time consuming than developing your own. As you begin to use Selenium no doubt you will start putting in your own \u0026ldquo;print statements\u0026rdquo; for reporting progress. That may gradually lead to you developing your own reporting, possibly in parallel to using a library or test framework. Regardless, after the initial, but short, learning curve you will naturally develop what works best for your own situation.\nTest Reporting Examples To illustrate, we\u0026rsquo;ll direct you to some specific tools in some of the other languages supported by Selenium. The ones listed here are commonly used and have been used extensively (and therefore recommended) by the authors of this guide.\nTest Reports in Java  If Selenium Test cases are developed using JUnit then JUnit Report can be used to generate test reports.\n If Selenium Test cases are developed using TestNG then no external task is required to generate test reports. The TestNG framework generates an HTML report which list details of tests.\n ReportNG is a HTML reporting plug-in for the TestNG framework. It is intended as a replacement for the default TestNG HTML report. ReportNG provides a simple, colour-coded view of the test results.\n  Logging the Selenese Commands  Logging Selenium can be used to generate a report of all the Selenese commands in your test along with the success or failure of each. Logging Selenium extends the Java client driver to add this Selenese logging ability.  Test Reports for Python  When using Python Client Driver then HTMLTestRunner can be used to generate a Test Report.  Test Reports for Ruby  If RSpec framework is used for writing Selenium Test Cases in Ruby then its HTML report can be used to generate a test report.  Adding Some Spice to Your Tests Now we\u0026rsquo;ll get to the whole reason for using Selenium RC, adding programming logic to your tests. It\u0026rsquo;s the same as for any program. Program flow is controlled using condition statements and iteration. In addition you can report progress information using I/O. In this section we\u0026rsquo;ll show some examples of how programming language constructs can be combined with Selenium to solve common testing problems.\nYou will find as you transition from the simple tests of the existence of page elements to tests of dynamic functionality involving multiple web-pages and varying data that you will require programming logic for verifying expected results. Basically, the Selenium-IDE does not support iteration and standard condition statements. You can do some conditions by embedding javascript in Selenese parameters, however iteration is impossible, and most conditions will be much easier in a\nprogramming language. In addition, you may need exception handling for error recovery. For these reasons and others, we have written this section to illustrate the use of common programming techniques to give you greater \u0026lsquo;verification power\u0026rsquo; in your automated testing.\nThe examples in this section are written in C# and Java, although the code is simple and can be easily adapted to the other supported languages. If you have some basic knowledge of an object-oriented programming language you shouldn\u0026rsquo;t have difficulty understanding this section.\nIteration Iteration is one of the most common things people need to do in their tests. For example, you may want to to execute a search multiple times. Or, perhaps for verifying your test results you need to process a \u0026ldquo;result set\u0026rdquo; returned from a database.\nUsing the same Google search example we used earlier, let\u0026rsquo;s check the Selenium search results. This test could use the Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     The code has been repeated to run the same steps 3 times. But multiple copies of the same code is not good program practice because it\u0026rsquo;s more work to maintain. By using a programming language, we can iterate over the search results for a more flexible and maintainable solution.\nIn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); }  Condition Statements To illustrate using conditions in tests we\u0026rsquo;ll start with an example. A common problem encountered while running Selenium tests occurs when an expected element is not available on page. For example, when running the following line:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); If element \u0026lsquo;q\u0026rsquo; is not on the page then an exception is thrown:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found This can cause your test to abort. For some tests that\u0026rsquo;s what you want. But often that is not desirable as your test script has many other subsequent tests to perform.\nA better approach is to first validate whether the element is really present and then take alternatives when it it is not. Let\u0026rsquo;s look at this using Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } The advantage of this approach is to continue with test execution even if some UI elements are not available on page.\nExecuting JavaScript from Your Test JavaScript comes very handy in exercising an application which is not directly supported by selenium. The getEval method of Selenium API can be used to execute JavaScript from Selenium RC.\nConsider an application having check boxes with no static identifiers. In this case one could evaluate JavaScript from Selenium RC to get ids of all check boxes and then exercise them.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } To count number of images on a page:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Remember to use window object in case of DOM expressions as by default selenium window is referred to, not the test window.\nServer Options When the server is launched, command line options can be used to change the default server behaviour.\nRecall, the server is started by running the following.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar To see the list of options, run the server with the -h option.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h You\u0026rsquo;ll see a list of all the options you can use with the server and a brief description of each. The provided descriptions will not always be enough, so we\u0026rsquo;ve provided explanations for some of the more important options.\nProxy Configuration If your AUT is behind an HTTP proxy which requires authentication then you should configure http.proxyHost, http.proxyPort, http.proxyUser and http.proxyPassword using the following command.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Multi-Window Mode If you are using Selenium 1.0 you can probably skip this section, since multiwindow mode is the default behavior. However, prior to version 1.0, Selenium by default ran the application under test in a sub frame as shown here.\nSome applications didn\u0026rsquo;t run correctly in a sub frame, and needed to be loaded into the top frame of the window. The multi-window mode option allowed the AUT to run in a separate window rather than in the default frame where it could then have the top frame it required.\nFor older versions of Selenium you must specify multiwindow mode explicitly with the following option:\n-multiwindow  As of Selenium RC 1.0, if you want to run your test within a single frame (i.e. using the standard for earlier Selenium versions) you can state this to the Selenium Server using the option\n-singlewindow  Specifying the Firefox Profile Firefox will not run two instances simultaneously unless you specify a separate profile for each instance. Selenium RC 1.0 and later runs in a separate profile automatically, so if you are using Selenium 1.0, you can probably skip this section. However, if you\u0026rsquo;re using an older version of Selenium or if you need to use a specific profile for your tests (such as adding an https certificate or having some addons installed), you will need to explicitly specify the profile.\nFirst, to create a separate Firefox profile, follow this procedure. Open the Windows Start menu, select \u0026ldquo;Run\u0026rdquo;, then type and enter one of the following:\nfirefox.exe -profilemanager firefox.exe -P  Create the new profile using the dialog. Then when you run Selenium Server, tell it to use this new Firefox profile with the server command-line option -firefoxProfileTemplate and specify the path to the profile using its filename and directory path.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34;  Warning: Be sure to put your profile in a new folder separate from the default!!! The Firefox profile manager tool will delete all files in a folder if you delete a profile, regardless of whether they are profile files or not.\nMore information about Firefox profiles can be found in Mozilla\u0026rsquo;s Knowledge Base\nRun Selenese Directly Within the Server Using -htmlSuite You can run Selenese html files directly within the Selenium Server by passing the html file to the server\u0026rsquo;s command line. For instance:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; This will automatically launch your HTML suite, run all the tests and save a nice HTML report with the results.\nNote: When using this option, the server will start the tests and wait for a specified number of seconds for the test to complete; if the test doesn\u0026rsquo;t complete within that amount of time, the command will exit with a non-zero exit code and no results file will be generated.\nThis command line is very long so be careful when you type it. Note this requires you to pass in an HTML Selenese suite, not a single test. Also be aware the -htmlSuite option is incompatible with -interactive You cannot run both at the same time.\nSelenium Server Logging Server-Side Logs When launching Selenium server the -log option can be used to record valuable debugging information reported by the Selenium Server to a text file.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log This log file is more verbose than the standard console logs (it includes DEBUG level logging messages). The log file also includes the logger name, and the ID number of the thread that logged the message. For example:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW The message format is\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE This message may be multiline.\nBrowser-Side Logs JavaScript on the browser side (Selenium Core) also logs important messages; in many cases, these can be more useful to the end-user than the regular Selenium Server logs. To access browser-side logs, pass the -browserSideLog argument to the Selenium Server.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog must be combined with the -log argument, to log browserSideLogs (as well as all other DEBUG level logging messages) to a file.\nSpecifying the Path to a Specific Browser You can specify to Selenium RC a path to a specific browser. This is useful if you have different versions of the same browser and you wish to use a specific one. Also, this is used to allow your tests to run against a browser not directly supported by Selenium RC. When specifying the run mode, use the *custom specifier followed by the full path to the browser\u0026rsquo;s executable:\n*custom \u0026lt;path to browser\u0026gt;  Selenium RC Architecture Note: This topic tries to explain the technical implementation behind Selenium RC. It\u0026rsquo;s not fundamental for a Selenium user to know this, but could be useful for understanding some of the problems you might find in the future.\nTo understand in detail how Selenium RC Server works and why it uses proxy injection and heightened privilege modes you must first understand the same origin policy_.\nThe Same Origin Policy The main restriction that Selenium faces is the Same Origin Policy. This security restriction is applied by every browser in the market and its objective is to ensure that a site\u0026rsquo;s content will never be accessible by a script from another site. The Same Origin Policy dictates that any code loaded within the browser can only operate within that website\u0026rsquo;s domain. It cannot perform functions on another website. So for example, if the browser loads JavaScript code when it loads www.mysite.com, it cannot run that loaded code against www.mysite2.com\u0026ndash;even if that\u0026rsquo;s another of your sites. If this were possible, a script placed on any website you open would be able to read information on your bank account if you had the account page opened on other tab. This is called XSS (Cross-site Scripting).\nTo work within this policy, Selenium-Core (and its JavaScript commands that make all the magic happen) must be placed in the same origin as the Application Under Test (same URL).\nHistorically, Selenium-Core was limited by this problem since it was implemented in JavaScript. Selenium RC is not, however, restricted by the Same Origin Policy. Its use of the Selenium Server as a proxy avoids this problem. It, essentially, tells the browser that the browser is working on a single \u0026ldquo;spoofed\u0026rdquo; website that the Server provides.\nNote: You can find additional information about this topic on Wikipedia pages about Same Origin Policy and XSS.\nProxy Injection The first method Selenium used to avoid the The Same Origin Policy was Proxy Injection. In Proxy Injection Mode, the Selenium Server acts as a client-configured HTTP proxy1, that sits between the browser and the Application Under Test2. It then masks the AUT under a fictional URL (embedding Selenium-Core and the set of tests and delivering them as if they were coming from the same origin).\nHere is an architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that injects Selenium-Core\u0026rsquo;s JavaScript into the browser-loaded web page. The client-driver passes a Selenese command to the server. The Server interprets the command and then triggers the corresponding JavaScript execution to execute that command within the browser. Selenium-Core instructs the browser to act on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks for the website\u0026rsquo;s content from the Selenium RC server (set as the HTTP proxy for the browser to use). Selenium RC server communicates with the Web server asking for the page and once it receives it, it sends the page to the browser masking the origin to look like the page comes from the same server as Selenium-Core (this allows Selenium-Core to comply with the Same Origin Policy). The browser receives the web page and renders it in the frame/window reserved for it.   Heightened Privileges Browsers This workflow in this method is very similar to Proxy Injection but the main difference is that the browsers are launched in a special mode called Heightened Privileges, which allows websites to do things that are not commonly permitted (as doing XSS_, or filling file upload inputs and pretty useful stuff for Selenium). By using these browser modes, Selenium Core is able to directly open the AUT and read/interact with its content without having to pass the whole AUT through the Selenium RC server.\nHere is the architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that will load Selenium-Core in the web page. Selenium-Core gets the first instruction from the client/driver (via another HTTP request made to the Selenium RC Server). Selenium-Core acts on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks the Web Server for the page. Once the browser receives the web page, renders it in the frame/window reserved for it.  Handling HTTPS and Security Popups Many applications switch from using HTTP to HTTPS when they need to send encrypted information such as passwords or credit card information. This is common with many of today\u0026rsquo;s web applications. Selenium RC supports this.\nTo ensure the HTTPS site is genuine, the browser will need a security certificate. Otherwise, when the browser accesses the AUT using HTTPS, it will assume that application is not \u0026lsquo;trusted\u0026rsquo;. When this occurs the browser displays security popups, and these popups cannot be closed using Selenium RC.\nWhen dealing with HTTPS in a Selenium RC test, you must use a run mode that supports this and handles the security certificate for you. You specify the run mode when your test program initializes Selenium.\nIn Selenium RC 1.0 beta 2 and later use *firefox or *iexplore for the run mode. In earlier versions, including Selenium RC 1.0 beta 1, use *chrome or *iehta, for the run mode. Using these run modes, you will not need to install any special security certificates; Selenium RC will handle it for you.\nIn version 1.0 the run modes *firefox or *iexplore are recommended. However, there are additional run modes of *iexploreproxy and *firefoxproxy. These are provided for backwards compatibility only, and should not be used unless required by legacy test programs. Their use will present limitations with security certificate handling and with the running of multiple windows if your application opens additional browser windows.\nIn earlier versions of Selenium RC, *chrome or *iehta were the run modes that supported HTTPS and the handling of security popups. These were considered ‘experimental modes although they became quite stable and many people used them. If you are using Selenium 1.0 you do not need, and should not use, these older run modes.\nSecurity Certificates Explained Normally, your browser will trust the application you are testing by installing a security certificate which you already own. You can check this in your browser\u0026rsquo;s options or Internet properties (if you don\u0026rsquo;t know your AUT\u0026rsquo;s security certificate ask your system administrator). When Selenium loads your browser it injects code to intercept messages between the browser and the server. The browser now thinks untrusted software is trying to look like your application. It responds by alerting you with popup messages.\nTo get around this, Selenium RC, (again when using a run mode that support this) will install its own security certificate, temporarily, to your client machine in a place where the browser can access it. This tricks the browser into thinking it\u0026rsquo;s accessing a site different from your AUT and effectively suppresses the popups.\nAnother method used with earlier versions of Selenium was to install the Cybervillians security certificate provided with your Selenium installation. Most users should no longer need to do this however; if you are running Selenium RC in proxy injection mode, you may need to explicitly install this security certificate.\nSupporting Additional Browsers and Browser Configurations The Selenium API supports running against multiple browsers in addition to Internet Explorer and Mozilla Firefox. See the https://selenium.dev website for supported browsers. In addition, when a browser is not directly supported, you may still run your Selenium tests against a browser of your choosing by using the \u0026ldquo;*custom\u0026rdquo; run-mode (i.e. in place of *firefox or *iexplore) when your test application starts the browser. With this, you pass in the path to the browsers executable within the API call. This can also be done from the Server in interactive mode.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Running Tests with Different Browser Configurations Normally Selenium RC automatically configures the browser, but if you launch the browser using the \u0026ldquo;*custom\u0026rdquo; run mode, you can force Selenium RC to launch the browser as-is, without using an automatic configuration.\nFor example, you can launch Firefox with a custom configuration like this:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Note that when launching the browser this way, you must manually configure the browser to use the Selenium Server as a proxy. Normally this just means opening your browser preferences and specifying \u0026ldquo;localhost:4444\u0026rdquo; as an HTTP proxy, but instructions for this can differ radically from browser to browser. Consult your browser\u0026rsquo;s documentation for details.\nBe aware that Mozilla browsers can vary in how they start and stop. One may need to set the MOZ_NO_REMOTE environment variable to make Mozilla browsers behave a little more predictably. Unix users should avoid launching the browser using a shell script; it\u0026rsquo;s generally better to use the binary executable (e.g. firefox-bin) directly.\nTroubleshooting Common Problems When getting started with Selenium RC there\u0026rsquo;s a few potential problems that are commonly encountered. We present them along with their solutions here.\nUnable to Connect to Server When your test program cannot connect to the Selenium Server, Selenium throws an exception in your test program. It should display this message or a similar one:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2)  If you see a message like this, be sure you started the Selenium Server. If so, then there is a problem with the connectivity between the Selenium Client Library and the Selenium Server.\nWhen starting with Selenium RC, most people begin by running their test program (with a Selenium Client Library) and the Selenium Server on the same machine. To do this use \u0026ldquo;localhost\u0026rdquo; as your connection parameter. We recommend beginning this way since it reduces the influence of potential networking problems which you\u0026rsquo;re getting started. Assuming your operating system has typical networking and TCP/IP settings you should have little difficulty. In truth, many people choose to run the tests this way.\nIf, however, you do want to run Selenium Server on a remote machine, the connectivity should be fine assuming you have valid TCP/IP connectivity between the two machines.\nIf you have difficulty connecting, you can use common networking tools like ping, telnet, ifconfig(Unix)/ipconfig (Windows), etc to ensure you have a valid network connection. If unfamilar with these, your system administrator can assist you.\nUnable to Load the Browser Ok, not a friendly error message, sorry, but if the Selenium Server cannot load the browser you will likely see this error.\n(500) Internal Server Error This could be caused by\n Firefox (prior to Selenium 1.0) cannot start because the browser is already open and you did not specify a separate profile. See the section on Firefox profiles under Server Options. The run mode you\u0026rsquo;re using doesn\u0026rsquo;t match any browser on your machine. Check the parameters you passed to Selenium when you program opens the browser. You specified the path to the browser explicitly (using \u0026ldquo;*custom\u0026rdquo;\u0026ndash;see above) but the path is incorrect. Check to be sure the path is correct. Also check the user group to be sure there are no known issues with your browser and the \u0026ldquo;*custom\u0026rdquo; parameters.  Selenium Cannot Find the AUT If your test program starts the browser successfully, but the browser doesn\u0026rsquo;t display the website you\u0026rsquo;re testing, the most likely cause is your test program is not using the correct URL.\nThis can easily happen. When you use Selenium-IDE to export your script, it inserts a dummy URL. You must manually change the URL to the correct one for your application to be tested.\nFirefox Refused Shutdown While Preparing a Profile This most often occurs when you run your Selenium RC test program against Firefox, but you already have a Firefox browser session running and, you didn\u0026rsquo;t specify a separate profile when you started the Selenium Server. The error from the test program looks like this:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile  Here\u0026rsquo;s the complete error message from the server:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock  To resolve this, see the section on Specifying a Separate Firefox Profile\nVersioning Problems Make sure your version of Selenium supports the version of your browser. For example, Selenium RC 0.92 does not support Firefox 3. At times you may be lucky (I was). But don\u0026rsquo;t forget to check which browser versions are supported by the version of Selenium you are using. When in doubt, use the latest release version of Selenium with the most widely used version of your browser.\nError message: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; while starting server This error says you\u0026rsquo;re not using a correct version of Java. The Selenium Server requires Java 1.5 or higher.\nTo check double-check your java version, run this from the command line.\njava -version You should see a message showing the Java version.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) If you see a lower version number, you may need to update the JRE, or you may simply need to add it to your PATH environment variable.\n404 error when running the getNewBrowserSession command If you\u0026rsquo;re getting a 404 error while attempting to open a page on \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, then it must be because the Selenium Server was not correctly configured as a proxy. The \u0026ldquo;selenium-server\u0026rdquo; directory doesn\u0026rsquo;t exist on google.com; it only appears to exist when the proxy is properly configured. Proxy Configuration highly depends on how the browser is launched with firefox, iexplore, opera, or custom.\n iexplore: If the browser is launched using *iexplore, you could be having a problem with Internet Explorer\u0026rsquo;s proxy settings. Selenium Server attempts To configure the global proxy settings in the Internet Options Control Panel. You must make sure that those are correctly configured when Selenium Server launches the browser. Try looking at your Internet Options control panel. Click on the \u0026ldquo;Connections\u0026rdquo; tab and click on \u0026ldquo;LAN Settings\u0026rdquo;.\n If you need to use a proxy to access the application you want to test, you\u0026rsquo;ll need to start Selenium Server with \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; see the Proxy Configuration_ for more details. You may also try configuring your proxy manually and then launching the browser with *custom, or with *iehta browser launcher.   custom: When using *custom you must configure the proxy correctly(manually), otherwise you\u0026rsquo;ll get a 404 error. Double-check that you\u0026rsquo;ve configured your proxy settings correctly. To check whether you\u0026rsquo;ve configured the proxy correctly is to attempt to intentionally configure the browser incorrectly. Try configuring the browser to use the wrong proxy server hostname, or the wrong port. If you had successfully configured the browser\u0026rsquo;s proxy settings incorrectly, then the browser will be unable to connect to the Internet, which is one way to make sure that one is adjusting the relevant settings.\n For other browsers (*firefox, *opera) we automatically hard-code the proxy for you, and so there are no known issues with this functionality. If you\u0026rsquo;re encountering 404 errors and have followed this user guide carefully post your results to user group for some help from the user community.\n  Permission Denied Error The most common reason for this error is that your session is attempting to violate the same-origin policy by crossing domain boundaries (e.g., accesses a page from http://domain1 and then accesses a page from http://domain2) or switching protocols (moving from http://domainX to https://domainX).\nThis error can also occur when JavaScript attempts to find UI objects which are not yet available (before the page has completely loaded), or are no longer available (after the page has started to be unloaded). This is most typically encountered with AJAX pages which are working with sections of a page or subframes that load and/or reload independently of the larger page.\nThis error can be intermittent. Often it is impossible to reproduce the problem with a debugger because the trouble stems from race conditions which are not reproducible when the debugger\u0026rsquo;s overhead is added to the system. Permission issues are covered in some detail in the tutorial. Read the section about the The Same Origin Policy, Proxy Injection carefully.\nHandling Browser Popup Windows There are several kinds of \u0026ldquo;Popups\u0026rdquo; that you can get during a Selenium test. You may not be able to close these popups by running Selenium commands if they are initiated by the browser and not your AUT. You may need to know how to manage these. Each type of popup needs to be addressed differently.\n HTTP basic authentication dialogs: These dialogs prompt for a username/password to login to the site. To login to a site that requires HTTP basic authentication, use a username and password in the URL, as described in RFC 1738_, like this: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n SSL certificate warnings: Selenium RC automatically attempts to spoof SSL certificates when it is enabled as a proxy; see more on this in the section on HTTPS. If your browser is configured correctly, you should never see SSL certificate warnings, but you may need to configure your browser to trust our dangerous \u0026ldquo;CyberVillains\u0026rdquo; SSL certificate authority. Again, refer to the HTTPS section for how to do this.\n modal JavaScript alert/confirmation/prompt dialogs: Selenium tries to conceal those dialogs from you (by replacing window.alert, window.confirm and window.prompt) so they won\u0026rsquo;t stop the execution of your page. If you\u0026rsquo;re seeing an alert pop-up, it\u0026rsquo;s probably because it fired during the page load process, which is usually too early for us to protect the page. Selenese contains commands for asserting or verifying alert and confirmation popups. See the sections on these topics in Chapter 4.\n  On Linux, why isn\u0026rsquo;t my Firefox browser session closing? On Unix/Linux you must invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so make sure that executable is on the path. If executing Firefox through a shell script, when it comes time to kill the browser Selenium RC will kill the shell script, leaving the browser running. You can specify the path to firefox-bin directly, like this.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome doesn\u0026rsquo;t work with custom profile Check Firefox profile folder -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comment this line like this: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; and try again.\nIs it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page\u0026rsquo;s javascript window.onload() function runs)? No. Selenium relies on interceptors to determine window names as they are being loaded. These interceptors work best in catching new windows if the windows are loaded AFTER the onload() function. Selenium may not recognize windows loaded before the onload function.\nFirefox on Linux On Unix/Linux, versions of Selenium before 1.0 needed to invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so if you are using a previous version, make sure that the real executable is on the path.\nOn most Linux distributions, the real firefox-bin is located on:\n/usr/lib/firefox-x.x.x/  Where the x.x.x is the version number you currently have. So, to add that path to the user\u0026rsquo;s path. you will have to add the following to your .bashrc file:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; If necessary, you can specify the path to firefox-bin directly in your test, like this:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE and Style Attributes If you are running your tests on Internet Explorer and you cannot locate elements using their style attribute. For example:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] This would work perfectly in Firefox, Opera or Safari but not with IE. IE interprets the keys in @style as uppercase. So, even if the source code is in lowercase, you should use:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] This is a problem if your test is intended to work on multiple browsers, but you can easily code your test to detect the situation and try the alternative locator that only works in IE.\nError encountered - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; with shut down of *googlechrome browser To avoid this error you have to start browser with an option that disables same origin policy checks:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Error encountered in IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; To avoid this error you have to configure the browser: disable the popup blocker AND uncheck \u0026lsquo;Enable Protected Mode\u0026rsquo; option in Tools \u0026gt;\u0026gt; Options \u0026gt;\u0026gt; Security.\n The proxy is a third person in the middle that passes the ball between the two parts. It acts as a \u0026ldquo;web server\u0026rdquo; that delivers the AUT to the browser. Being a proxy gives Selenium Server the capability of \u0026ldquo;lying\u0026rdquo; about the AUT\u0026rsquo;s real URL.\n[return] The browser is launched with a configuration profile that has set localhost:4444 as the HTTP proxy, this is why any HTTP request that the browser does will pass through Selenium server and the response will pass through it and not from the real server. [return]   "
},
{
	"uri": "https://selenium.dev/documentation/es/driver_idiosyncrasies/shared_capabilities/",
	"title": "Shared capabilities",
	"tags": [],
	"description": "",
	"content": " Con el fin de crear una nueva sesión del WebDriver de Selenium, la parte local debe proveer las capacidades(capabilities) básicas a la parte remota. La parte remota usa el mismo conjunto de capacidades para crear una sesión y describir las funcionalidades de la sesión actual.\nEl WebDriver proporciona unas capacidades que cada parte remota debe apoyar en su implementación. Las siguientes capacidades son las que el WebDriver soporta:\nbrowserName: Esta capacidad es usada para fijar el browserName(nombre del navegador) para una sesión dada. Si el navegador especificado no esta instado en la parte remota, la creación la sesión fallará.\nbrowserVersion: Esta capacidad es opcional, es usada para fijar la versión disponible del navegador en la parte remota. Por ejemplo, si preguntamos por una versión 75 de Chrome en un sistema que solo tiene instalada la versión 80 instalada, la creación de la sesión fallará.\npageLoadStrategy: Cuando navegamos a una nueva pagina vía URL, por defecto Selenium esperará hasta que la pagina este cargada completamente antes de responder. Esto funciona bien para principiantes, pero puede causar largos tiempos de espera en paginas que cargan una gran cantidad de recursos externos. Usando alguna de las estrategias que no están especificadas por defecto puedes hacer que tus tests se ejecuten mas rápidamente pero también podrías llegar a introducir problemas de fiabilidad donde los elementos de la pagina cambian de posición según estos elementos van cargando.\nLa estrategia de carga de las paginas consulta el atributo document.readyState como se describe en la tabla siguiente:\n   Estrategia Estado Atributo Ready Notas     normal complete Usado por defecto, espera a que todos los recursos se descarguen   eager interactive Acceso al DOM esta listo, pero los otros recursos como imágenes pueden estar cargando   none Any No bloquea al WebDriver en absoluto    platformName Esto es usado para identificar el sistema operativo en la parte remota, buscar la capacidad platformName devuelve el sistema operativo.\nEn proveedores basados en la nube, fijar la capacidad platformName permite definir el sistema operativo de la parte remota.\nacceptInsecureCerts Esta capacidad comprueba si un certificado TLS ha vencido o es invalido esta siendo usado para navegar durante una sesión.\nSi esta capacidad esta fijada a false, un error de certificado inseguro sera devuelto cuando la navegación encuentre cualquier dominio con problemas de certificado. Si se fija a true, los certificados inválidos serán confiados por el navegador\nTodos los certificados auto-firmados serán confiables por esta capacidad por defecto. Una vez. Una vez fijado la capacidad acceptInsecureCerts tendrá efecto durante la sesión entera.\nTimeouts de sesión Una sesión del WebDriver es impuesta con un cierto intervalo de timeout de sesión durante el cual el usuario puede controlar el comportamiento de ejecutar scripts o recuperar información del navegador.\nCada timeout de sesión es configurado con una combinación diferente de timeouts como se describe a continuación:\nTimeout de script (Script Timeout): Especifica cuando interrumpir un script en ejecución en el contexto actual del navegador. Por defecto esta configurado a 30,000 cuando una nueva sesión es creada por el WebDriver.\nTimeout de tiempo de carga (Page Load Timeout): Especifica el intervalo de tiempo en el cual una pagina de web necesita ser cargada en el contexto actual del navegador. El timeout por defecto es de 300,000 para las nuevas sesiones creadas por el WebDriver. Si el tiempo de carga excede el limite marcado, el script será parado por una excepción del tipo TimeoutException.\nTimeout de esperas implicitas (Implicit Wait Timeout): Esto especifica el tiempo de espera para la estrategia de localización de elementos implicita. Por defecto el timeout es de 0, este es impuesto cuando se crea una nueva sesión a través del WebDriver.\nGestionar el comportamiento de las popups Prompt (unhandledPromptBehavior) Especifica la forma en la que el usuario puede manejar las popups prompt (user prompt handler) en la sesión actual. El valor predeterminado es dismiss and notify state\nManejo de las popups Prompt (User Prompt Handler) Esto define que acción se debe tomar cuando aparece una ventana prompt en la parte remota. Es definida por la capacidad unhandledPromptBehavior y tiene los siguientes estados:\n dismiss accept dismiss and notify accept and notify ignore  setWindowRect This command alters the size and position of the current browsing context window. This command acts as setter to getWindowRect command which accepts width, height, x, y as optional arguments.\nDuring automation, the current browsing context will be associated with window states, that describe visibility state of the browser window. The window states are\n maximized minimized normal fullscreen  Setting Width or Height does not guaranteed that the resulting window size will exactly match that which was quested. This is because some drivers may not be able to resize in single-pixel increments. Due to this, fetching the window state/details by getWindowRect may not equally match the values set to the browser.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/remote_webdriver/remote_webdriver_server/",
	"title": "WebDriver remoto - servidor",
	"tags": [],
	"description": "",
	"content": " El servidor siempre se ejecutará en la máquina con el navegador que deseas probar. El servidor se puede usar desde la línea de comandos o mediante configuración de código.\nIniciar el servidor desde la línea de comando Una vez que hayas descargado selenium-server-standalone-{VERSION}.jar, colócalo en la computadora con el navegador que deseas probar. Entonces, desde el directorio con el jar, ejecuta lo siguiente:\njava -jar selenium-server-standalone-{VERSION}.jar Consideraciones para ejecutar el servidor Se espera que quien inicie la sesión termine cada sesión correctamente, llamando ya sea Selenium#stop() o WebDriver#quit.\nEl servidor de Selenium mantiene registros en memoria para cada sesión en curso, que se borran cuando se invoca Selenium#stop() o WebDriver#quit. Si olvidas finalizar estas sesiones, tu servidor puede perder memoria. Si mantienes sesiones extremadamente largas, probablemente necesitarás detener/salir de vez en cuando (o también aumentar la memoria con la opción -Xmx jvm).\nTimeouts (desde la version 2.21) El servidor tiene dos timeouts diferentes, que se pueden configurar de la siguiente manera:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controla cuánto tiempo se permite colgar el navegador (valor en segundos).  timeout  Controla cuánto tiempo se permite que el cliente se vaya antes de reclamar la sesión (valor en segundos).   La propiedad del sistema selenium.server.session.timeout ya no es compatible a partir de 2.21.\nTen en cuenta que el browserTimeout está pensado como un mecanismo de timeout de respaldo cuando falla el mecanismo de timeout ordinario, que debe usarse principalmente en entornos de red/servidor para garantizar que los procesos bloqueados/perdidos no permanezcan por mucho tiempo,contaminando el entorno de ejecución.\nConfiguración del servidor de manera programática En teoría, el proceso es tan simple como mapear el DriverServlet a una URL, pero también es posible alojar la página desde en un contenedor ligero, como Jetty configurado completamente en código. Pasos para hacer esto a continuación.\n Descargar selenium-server.zip y descomprimirlos Poner los JAR en el CLASSPATH Crear una nueva clase llamada AppServer. Estoy usando Jetty, por lo que deberás descargar eso también:\nimport org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } }  "
},
{
	"uri": "https://selenium.dev/documentation/es/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "Capacidades específicas de los Drivers",
	"tags": [],
	"description": "",
	"content": " Firefox Define las capacidades usando FirefoxOptions FirefoxOptions es la nueva forma de definir capacidades para el navegador Firefox y debe de ser usado de manera general antes que DesriredCapabilities.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Fijando un perfil a medida Es posible crear perfiles a medida para Firefox, como se puede ver a continuación.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer Timeout ventana de selección de archivos (fileUploadDialogTimeout) En algunos entornos, Internet Explorer puede devolver un timeout cuando se abra una ventana de selección de archivos (file upload dialog). Por defecto el IEDriver tiene un timeout de 1000ms, pero puedes incrementarlo usando la capacidad fileUploadDialogTimeout.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   options = webdriver.IeOptions options.file_upload_dialog_timeout(2000) driver = webdriver.Ie(ie_driver_path, options=options)   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let options = new ie.Options().fileUploadDialogTimeout(2000); let driver = await Builder() .setIeOptions(options) .build();   val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/components_of_a_grid/",
	"title": "Componentes de un Grid",
	"tags": [],
	"description": "",
	"content": " Hub  Ejerce como mediador y administrador Acepta peticiones para ejecutar los tests Recoge instrucciones de los clientes y las ejecuta de forma remota en los nodos Gestiona los hilos  El Hub es un punto central donde se envian todos tus tests. Cada Selenium Grid consiste en exactamente un hub. El hub necesita ser accesible desde la perspectiva de los clientes (ej. Servidor de la CI, maquina del desarrollador) El hub se conectará a uno o mas nodos a los que los tests serán delegados.\nNodos  Donde se ubican los navegadores Se registra a si mismo en el hub y le comunica sus capacidades Recibe las peticiones desde el hub las ejecuta  Los nodos son diferentes instancias de Selenium que ejecutarán los tests en sistemas informáticos individuales. Puedes haber muchos nodos en un grid. Las maquinas que contienen los nodos no necesitan estar bajo el mismo sistema operativo o disponer de la misma selección de navegadores que el hub u otros nodos. Un nodo en Windows podría tener la capacidad de ofrecer Internet Explorer como opción del navegador mientras que esto no podría ser posible en Linux o Mac.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/front_matter/typographical_conventions/",
	"title": "Convenciones tipográficas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Capitalisation of titles One should avoid title capitalisation, such as A Very Fine Heading, and instead go for A very fine heading. Gratutious capitalisation, or title case, often show a misunderstanding of – or a disregard for – orthographic conventions. We prefer what is known as sentence case, with a single initial capital to start headers.\nLine length When editing the documentation’s source, which is written in plain HTML, limit your line lengths to around 72 characters.\nSome of us take this one step further and use what is called semantic linefeeds, which is a technique whereby the HTML source lines, which are not read by the public, are split at ‘natural breaks’ in the prose. In other words, sentences are split at natural breaks between clauses. Instead of fussing with the lines of each paragraph so that they all end near the right margin, linefeeds can be added anywhere that there is a break between ideas.\nThis can make diffs very easy to read when collaborating through git, but it is not something we enforce contributors to use.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/file_downloads/",
	"title": "Descarga de archivos",
	"tags": [],
	"description": "",
	"content": "Mientras que es posible empezar una descarga haciendo clic en el enlace, con el navegador que este siendo controlado por Selenium, el API no expone el progreso de la descarga, haciéndolo poco ideal para probar la descarga de archivos. Esto es debido a que descargar archivos no es considerado un aspecto importante de la emulación de las interacciones de los usuarios con las plataformas web. En lugar de ello, se recomienda encontrar el enlace con Selenium (y cualquier Cookie requerida) y pasarselo a una librería que permita hacer peticiones HTTP como libcurl.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/installing_webdriver_binaries/",
	"title": "Instalando los binarios de WebDriver",
	"tags": [],
	"description": "",
	"content": "Para ejecutar tu proyecto y controlar el navegador, debes tener instalados los binarios de WebDriver específicos para el navegador.\nDescarga el binario de WebDriver soportado por tu navegador y colócalo en el PATH del sistema.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/",
	"title": "Introducción",
	"tags": [],
	"description": "",
	"content": " Introducción Selenium es un proyecto que alberga un catálogo de herramientas y librerías que permiten y sustentan la automatización de navegadores web.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/domain_specific_language/",
	"title": "Lenguage de dominio específico",
	"tags": [],
	"description": "",
	"content": " Un lenguaje de dominio específico (DSL) es un sistema que proporciona al usuario un medio expresivo para resolver un problema. Permite a un usuario interactuar con el sistema en sus términos, no solo en jerga del programador.\nA tus usuarios, en general, no les importa cómo se ve su sitio. Ellos no se preocupan por la decoración, animaciones o gráficos. Ellos desean utilizar tu sistema para impulsar a sus nuevos empleados a través del proceso con mínima dificultad; quieren reservar un viaje a Alaska; quieren configurar y comprar unicornios con descuento. Tu trabajo como el probador debe acercarse lo más que pueda a \u0026ldquo;capturar\u0026rdquo; esta mentalidad. Con eso en mente, nos propusimos \u0026ldquo;modelar\u0026rdquo; la aplicación con que estas trabajando, de modo que los scripts de prueba (el único proxy pre-lanzamiento del usuario ) \u0026ldquo;hablen\u0026rdquo; por, y representen al usuario.\nCon Selenium, el DSL generalmente se representa por métodos, escritos para hacer la API simple y legible: permiten un informe entre desarrolladores y partes interesadas (usuarios, dueños de producto, especialistas en inteligencia de negocios, etc).\nBeneficios  Legible: Las partes interesadas del negocio pueden entenderlo. Escribible: Fácil de escribir, evita duplicaciones innecesarias. Extensible: Se puede agregar funcionalidad (razonablemente) sin romper los contratos y la funcionalidad existente. Mantenible: Al dejar los detalles de implementación fuera de casos de prueba, está bien aislado contra cambios en el AUT*.  Java Aquí hay un ejemplo de un método DSL razonable en Java. En aras de la brevedad, se supone que el objeto driver está predefinido y disponible para el método.\n/** * Toma un nombre de usuario y una contraseña, completa los campos y hace clic en \u0026#34;iniciar sesión\u0026#34;. * @return Una instancia de AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Completa el campo de contraseña. El localizador que estamos usando es \u0026#34;By.id\u0026#34;, y deberíamos  // tenerlo definido en otra parte de la clase.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Haz clic en el botón de inicio de sesión, que tiene el id \u0026#34;enviar\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Crea y devuelve una nueva instancia de AccountPage (a través del PageFactory  // incorporado a Selenium).  return PageFactory.newInstance(AccountPage.class); } Este método abstrae completamente los conceptos de campos de entrada, botones, clics e incluso páginas de tu código de prueba. Usando este enfoque, todo lo que un probador tiene que hacer es llamar a este método. Esto da una ventaja de mantenimiento: si los campos de inicio de sesión alguna vez cambian, solo tendrías que cambiar este método, no tus pruebas.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Ahora que hemos iniciado sesión, haz otras cosas, ya que utilizamos un DSL para admitir  // nuestros probadore, es tan fácil como elegir entre los métodos disponibles.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Ten en cuenta que todavía no nos hemos referido a un botón o control web en ninguna parte de este  // script... } Vale la pena repetirlo: uno de tus objetivos principales debe ser escribir un API que permite que tus pruebas aborden el problema en cuestión, y NO el problema de la interfaz de usuario. La interfaz de usuario es una preocupación secundaria para tus usuarios: no les importa la interfaz de usuario, solo quieren obtener su trabajo hecho. Tus scripts de prueba deben leerse como una lista de cosas el usuario quiere HACER, y las cosas que quiere SABER. Las pruebas no deben preocuparse por CÓMO la IU requiere que vayas al respecto.\n*AUT: Application under test\n"
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "Migrating from RC to WebDriver",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n How to Migrate to Selenium WebDriver A common question when adopting Selenium 2 is what\u0026rsquo;s the correct thing to do when adding new tests to an existing set of tests? Users who are new to the framework can begin by using the new WebDriver APIs for writing their tests. But what of users who already have suites of existing tests? This guide is designed to demonstrate how to migrate your existing tests to the new APIs, allowing all new tests to be written using the new features offered by WebDriver.\nThe method presented here describes a piecemeal migration to the WebDriver APIs without needing to rework everything in one massive push. This means that you can allow more time for migrating your existing tests, which may make it easier for you to decide where to spend your effort.\nThis guide is written using Java, because this has the best support for making the migration. As we provide better tools for other languages, this guide shall be expanded to include those languages.\nWhy Migrate to WebDriver Moving a suite of tests from one API to another API requires an enormous amount of effort. Why would you and your team consider making this move? Here are some reasons why you should consider migrating your Selenium Tests to use WebDriver.\n Smaller, compact API. WebDriver\u0026rsquo;s API is more Object Oriented than the original Selenium RC API. This can make it easier to work with. Better emulation of user interactions. Where possible, WebDriver makes use of native events in order to interact with a web page. This more closely mimics the way that your users work with your site and apps. In addition, WebDriver offers the advanced user interactions APIs which allow you to model complex interactions with your site. Support by browser vendors. Opera, Mozilla and Google are all active participants in WebDriver\u0026rsquo;s development, and each have engineers working to improve the framework. Often, this means that support for WebDriver is baked into the browser itself: your tests run as fast and as stably as possible.  Before Starting In order to make the process of migrating as painless as possible, make sure that all your tests run properly with the latest Selenium release. This may sound obvious, but it\u0026rsquo;s best to have it said!\nGetting Started The first step when starting the migration is to change how you obtain your instance of Selenium. When using Selenium RC, this is done like so:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); This should be replaced like so:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Next Steps Once your tests execute without errors, the next stage is to migrate the actual test code to use the WebDriver APIs. Depending on how well abstracted your code is, this might be a short process or a long one. In either case, the approach is the same and can be summed up simply: modify code to use the new API when you come to edit it.\nIf you need to extract the underlying WebDriver implementation from the Selenium instance, you can simply cast it to WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); This allows you to continue passing the Selenium instance around as normal, but to unwrap the WebDriver instance as required.\nAt some point, you\u0026rsquo;re codebase will mostly be using the newer APIs. At this point, you can flip the relationship, using WebDriver throughout and instantiating a Selenium instance on demand:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Common Problems Fortunately, you\u0026rsquo;re not the first person to go through this migration, so here are some common problems that others have seen, and how to solve them.\nClicking and Typing is More Complete A common pattern in a Selenium RC test is to see something like:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); This relies on the fact that \u0026ldquo;type\u0026rdquo; simply replaces the content of the identified element without also firing all the events that would normally be fired if a user interacts with the page. The final direct invocations of \u0026ldquo;key*\u0026rdquo; cause the JS handlers to fire as expected.\nWhen using the WebDriverBackedSelenium, the result of filling in the form field would be \u0026ldquo;exciting texttt\u0026rdquo;: not what you\u0026rsquo;d expect! The reason for this is that WebDriver more accurately emulates user behavior, and so will have been firing events all along.\nThis same fact may sometimes cause a page load to fire earlier than it would do in a Selenium 1 test. You can tell that this has happened if a \u0026ldquo;StaleElementException\u0026rdquo; is thrown by WebDriver.\nWaitForPageToLoad Returns Too Soon Discovering when a page load is complete is a tricky business. Do we mean \u0026ldquo;when the load event fires\u0026rdquo;, \u0026ldquo;when all AJAX requests are complete\u0026rdquo;, \u0026ldquo;when there\u0026rsquo;s no network traffic\u0026rdquo;, \u0026ldquo;when document.readyState has changed\u0026rdquo; or something else entirely?\nWebDriver attempts to simulate the original Selenium behavior, but this doesn\u0026rsquo;t always work perfectly for various reasons. The most common reason is that it\u0026rsquo;s hard to tell the difference between a page load not having started yet, and a page load having completed between method calls. This sometimes means that control is returned to your test before the page has finished (or even started!) loading.\nThe solution to this is to wait on something specific. Commonly, this might be for the element you want to interact with next, or for some Javascript variable to be set to a specific value. An example would be:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Where \u0026ldquo;visibilityOfElementLocated\u0026rdquo; is implemented as:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } This may look complex, but it\u0026rsquo;s almost all boiler-plate code. The only interesting bit is that the \u0026ldquo;ExpectedCondition\u0026rdquo; will be evaluated repeatedly until the \u0026ldquo;apply\u0026rdquo; method returns something that is neither \u0026ldquo;null\u0026rdquo; nor Boolean.FALSE.\nOf course, adding all these \u0026ldquo;wait\u0026rdquo; calls may clutter up your code. If that\u0026rsquo;s the case, and your needs are simple, consider using the implicit waits:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); By doing this, every time an element is located, if the element is not present, the location is retried until either it is present, or until 30 seconds have passed.\nFinding By XPath or CSS Selectors Doesn\u0026rsquo;t Always Work, But It Does In Selenium 1 In Selenium 1, it was common for xpath to use a bundled library rather than the capabilities of the browser itself. WebDriver will always use the native browser methods unless there\u0026rsquo;s no alternative. That means that complex xpath expressions may break on some browsers.\nCSS Selectors in Selenium 1 were implemented using the Sizzle library. This implements a superset of the CSS Selector spec, and it\u0026rsquo;s not always clear where you\u0026rsquo;ve crossed the line. If you\u0026rsquo;re using the WebDriverBackedSelenium and use a Sizzle locator instead of a CSS Selector for finding elements, a warning will be logged to the console. It\u0026rsquo;s worth taking the time to look for these, particularly if tests are failing because of not being able to find elements.\nThere is No Browserbot Selenium RC was based on Selenium Core, and therefore when you executed Javascript, you could access bits of Selenium Core to make things easier. As WebDriver is not based on Selenium Core, this is no longer possible. How can you tell if you\u0026rsquo;re using Selenium Core? Simple! Just look to see if your \u0026ldquo;getEval\u0026rdquo; or similar calls are using \u0026ldquo;selenium\u0026rdquo; or \u0026ldquo;browserbot\u0026rdquo; in the evaluated Javascript.\nYou might be using the browserbot to obtain a handle to the current window or document of the test. Fortunately, WebDriver always evaluates JS in the context of the current window, so you can use \u0026ldquo;window\u0026rdquo; or \u0026ldquo;document\u0026rdquo; directly.\nAlternatively, you might be using the browserbot to locate elements. In WebDriver, the idiom for doing this is to first locate the element, and then pass that as an argument to the Javascript. Thus:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); becomes:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Notice how the passed in \u0026ldquo;element\u0026rdquo; variable appears as the first item in the JS standard \u0026ldquo;arguments\u0026rdquo; array.\nExecuting Javascript Doesn\u0026rsquo;t Return Anything WebDriver\u0026rsquo;s JavascriptExecutor will wrap all JS and evaluate it as an anonymous expression. This means that you need to use the \u0026ldquo;return\u0026rdquo; keyword:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); becomes:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;);"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Navegadores de terceros y plugins",
	"tags": [],
	"description": "",
	"content": "Selenium se puede extender mediante el uso de plugins. Aquí hay una serie de plugins creados y mantenidos por terceros. Para más información sobre cómo crear tu propio plugin o tenerlo en la lista, consulta la documentación.\nTen en cuenta que estos plugins no son compatibles, mantenidos, alojados o avalados por el proyecto Selenium. Además, ten en cuenta que los plugins enumerados a continuación no necesariamente están licenciados bajo la licencia de Apache v.2.0. Algunos de los plugins están disponibles bajo otra licencia de software libre y de código abierto. Otros solo están disponibles bajo una licencia patentada. Cualquier pregunta acerca de los plugins y su licencia de distribución deben plantearse con sus respectivo(s) desarrollador(es).\n   Navegador Más reciente Registro de cambios Seguimiento de Incidentes     Mozilla GeckoDriver más reciente registro de cambios seguimiento de incidentes   Google Chrome Driver más reciente registro de cambios seguimiento de incidentes   Opera más reciente - seguimiento de incidentes   Microsoft Edge Driver más reciente - seguimiento de incidentes   SafariDriver Incorporado - seguimiento de incidentes    "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/driver_requirements/",
	"title": "Requerimientos de los controladores",
	"tags": [],
	"description": "",
	"content": " A través del WebDriver, Selenium es capaz de soportar los navegadores mas usados en el mercado como Chrom(ium), Firefox, Internet Explorer, Opera y Safari. WebDriver maneja los navegadores, cuando es posible, apoyándose en las propias funciones que el navegador incorpora para la automatización.\nLa finalidad del WebDriver es emular las interacciones de los usuarios reales. Esto es posible en diversos niveles en diferentes navegadores. Para mas detalles sobre las diferentes comportamientos de los controladores, ver Comportamientos del controlador.\nAunque todos los controladores comparten una única interfaz orientada al usuario para manejar los navegadores, todos ellos tienen diferentes formas de establecer las sesiones. Ya que muchas de estas implementaciones son realizadas por terceras personas y no están incluidas en la distribución estándar de Selenium.\nLa instanciación del controlador, el tratamiento de perfiles y algunos ajustes específicos de cada navegador son ejemplos de parámetros que tienen diferentes requisitos dependiendo del navegador.\nEsta sección explica los requisitos básicos para comenzar a trabajar con diferentes navegadores.\nAñadiendo los ejecutables al PATH del sistema La gran mayoría de controladores necesitan de un ejecutable extra para que Selenium pueda comunicarse con el navegador. Puedes especificar manualmente donde esta ubicado el ejecutable antes lanzar el WebDriver, pero esto hará que tus tests sean menos portables, ya que los ejecutables necesitan estar en el mismo lugar en todas las maquinas, o que este incluido en el repositorio.\nAñadir una carpeta que contenga los binarios del WebDriver a tu sistema, permitirá a Selenium localizar los binarios necesarios adicionales sin la necesidad de tener que incluir en el código de los tests la ruta exacta.\n Crea un directorio para almacenar los ejecutables en el, como C:\\WebDriver\\bin o /opt/WebDriver/bin Añade el directorio al PATH del sistema:\n En Windows - Abre una terminal de comando como administrador y ejecuta el siguiente comando para añadir permanentemente el directorio a tu PATH para todos los usuarios de tu maquina:\nsetx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34; En macOS y Linux ejecutar el siguiente comando en una terminal:\nexport PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile  Ahora puedes probar los cambios. Para ello cierra todas las terminales de comando y abre una nueva Escribe el nombre de uno de los binarios que has añadido en la carpeta en el paso previo. p. ej.:\nchromedriver Si tu PATH ha sido configurado correctamente, verás una salida relacionada con la puesta en marcha del controlador:\nStarting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed.  Puedes recuperar el control de la consola de comandos pulsando Ctrl + C\nReferencia Rápida    Navegador SO Soportados Mantenido por Descargas Issues     Chromium/Chrome Windows/macOS/Linux Google Descargas Incidentes   Firefox Windows/macOS/Linux Mozilla Descargas Incidentes   Edge Windows 10 Microsoft Descargas Incidentes   Internet Explorer Windows Proyecto de Selenium Descargas Incidentes   Safari macOS El Capitan and newer Apple Integrado Incidentes   Opera Windows/macOS/Linux Opera Descargas Incidentes    Chromium/Chrome Para controlar Chrome o Chromium, tienes que descargar chromedriver y almacenarlo en una carpeta que esté en el PATH del sistema.\nEn Linux y en macOS esto significa que tienes que modificar la variable de entorno PATH.\nPuedes ver que directorios están incluidos en esta variable, los directorios se separan mediante dos puntos.\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin Para incluir el chromedriver en el PATH si no lo estuviera, hay que asegurarse que incluimos la ruta donde se almacena el binario del chromedriver. Recuerda que puedes fijar la ruta al ejecutable del chromedriver usando la siguiente linea, esto te permitirá añadir el contenido actual del PATH mas una ruta adicional después de los dos puntos:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; Cuando el chromedriver este en el PATH este podrá ser ejecutado desde cualquier directorio. Para instanciar una sesión de Chrome/Chromium puedes hacer lo siguiente:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Asignación simple from selenium.webdriver import Chrome driver = Chrome() #Como gestor de contexto from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     Recuerda que tienes que fijar la ruta al ejecutable del chromedriver. Lo puedes hacer de la siguiente forma:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     El chromedriver esta implementado como un servidor remoto el cual expone la interfaz del proxy para la automatización de chrome, enseñando asi al navegador que hacer.\nFirefox Con la salida de Selenium 3, Mozilla se ha encargado de la implementación del controlador de Firefox, a través del geckodriver. Este nuevo controlador se llama geckodriver y funciona a partir de la versión 48 de Firefox. Como este controlador sigue en desarrollo, cuanto mas nueva sea la versión de Firefox mas respaldo tendrá por parte de Mozilla.\nComo geckodriver es la nueva forma por defecto de lanzar Firefox, puedes instanciar Firefox de la misma forma en Selenium 2:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Asignación simple from selenium.webdriver import Firefox driver = Firefox() #Como gestor de contexto from selenium.webdriver import Firefox with Firefox() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     Si no quisieras fijar la ruta del geckodriver en el PATH, puedes fijar la ruta del ejecutable como propiedad del sistema:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     En ciertos lenguajes de programación también es posible fijar la propiedad en tiempo de ejecución:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver Actualmente también es posible revertir al controlador antiguo de Firefox, el cual es un controlador mas completo, instalando la versión 47.0.1 o 45 ESR y especificando la capacidad deseada del controlador marionette como false. Las ultimas versiones de Firefox ya no son compatibles con este controlador.\nEdge Edge es el navegador mas nuevo de Microsoft, incluido en Windows 10 y Microsoft Server 2016. Las actualizaciones de Edge están incluidas en las actualizaciones principales de Windows, es por eso que necesitaras descargar el binario que coincida con la versión que tengas en ese momento instalada de Windows. La web de desarrolladores de Edge contiene los enlaces a todos los binarios disponibles.\nLos bugs de la implementación del EdgeDriver se pueden encontrar en Microsoft.\nSi deseas lanzar los tests contra Edge pero tu sistema operativo no es Windows 10, Microsoft ofrece maquinas virtuales en la web de desarrolladores de Edge.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Asignación simple from selenium.webdriver import Edge driver = Edge() #Como gestor de contexto: from selenium.webdriver import Edge with Edge() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     Si el controlador de Edge no esta presente en el PATH, puedes añadirlo con el siguiente comando:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const edge = require(\u0026#39;selenium-webdriver/edge\u0026#39;); let service = new edge.ServiceBuilder(\u0026#34;/path/to/msedgedriver.exe\u0026#34;); (async function test() { let driver = await new Builder() .setEdgeService(service) .forBrowser(\u0026#39;MicrosoftEdge\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorer era el navegador por defecto hasta la salida de Windows 10, aunque todavía esta incluido en Windows 10. El controlador de Internet Explorer es el único que Selenium tiene como objetivo admitir las mismas versiones que Microsoft considera como actuales. Las versiones anteriores pueden funcionar pero no serán mantenidas.\nA pesar de que Selenium proporciona los binarios para las versiones de 32 y 64 bits de Internet Explorer existen algunas limitaciones respecto a las versiones 10 y 11 para el controlador de 64-bits, en cambio el controlador de 32-bits funciona correctamente. Hay que tener en cuenta que las preferencias de Internet Explorer se guardan en la cuenta del usuario conectado, ademas es necesario realizar configuraciones adicionales\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Asignación simple from selenium.webdriver import Ie driver = Ie() #Como gestor de contexto from selenium.webdriver import Ie with Ie() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     Si el controlador de Internet Explorer no esta presente en el PATH, puedes añadirlo usando la siguiente linea:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const ie = require(\u0026#39;selenium-webdriver/ie\u0026#39;); let service = new ie.ServiceBuilder(\u0026#34;/path/to/IEDriverServer.exe\u0026#34;); (async function test() { let driver = await new Builder() .setIeService(service) .forBrowser(\u0026#39;internet explorer\u0026#39;) .build(); })();   System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     Microsoft tambien ofrece un binario para Internet Explorer 11 en Windows 7 y 8.1. El cual no ha sido actualizado desde 2014 y está basado en una versión preeliminar de la especificación del W3C. Jim Evans hizo un informe excelente sobre la implementación del controlador.\nOpera Las versiones actuales de Opera están construidas con el motor de Chromium, y WebDriver ahora es soportado a través del controlador de código propietario de Opera el cual puede ser añadido al PATH o configurado como propiedad del sistema.\nInstanciar una sesión del controlador es similar a como se hace el Firefox y Chromium:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Asignación simple from selenium.webdriver import Opera driver = Opera() #Como gestor de contexto from selenium.webdriver import Opera with Opera() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   const {Builder} = require(\u0026#34;selenium-webdriver\u0026#34;); const opera = require(\u0026#39;selenium-webdriver/opera\u0026#39;); (async function test() { let driver = await new Builder() .forBrowser(\u0026#39;opera\u0026#39;) .build(); })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari Para las versiones High Sierra y superiores: * Al Lanzar el siguiente comando desde la terminal por primera vez se debe escribir la contraseña para autorizar al WebDriver\nsafaridriver --enable Para El Capitan y Sierra:\n Activar el menú desarrollador desde las preferencias de Safari Seleccionar la opción Permitir automatización desde el menú del desarrollador Ejecutar el siguiente comando desde la terminal y escribir la contraseña para autorizar al WebDriver\n/usr/bin/safaridriver -p 1337\u0026lt;/  Una vez realizar podrás comenzar una sesión usando:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Asignación simple from selenium.webdriver import Safari driver = Safari() #Como gestor de contexto from selenium.webdriver import Safari with Safari() as driver: #El código con este nivel de tabulación   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     Aquellos que busquen automatizar Safari en iOS deberían echarle un vistazo al proyecto de Appium Aunque antes Safari estuviera disponible en Windows, Apple hace tiempo que dejo de mantenerlo, convirtiendo así a Windows en una pobre elección para la automatización de pruebas sobre Safari\nNavegadores simulados HtmlUnit HtmlUnit es un navegador sin interfaz grafica para programas basados en Java. Modela documentos HTML y proporciona un API que permite invocar las paginas, rellanar formularios, hacer clic en enlaces, etc. Soporta JavaScript y es capaz de funcionar con librerías AJAX, simulando Chrome, Firefox o Internet Explorer dependiendo de la configuración usada. Se ha migrado a una nueva web. El código fuente es mantenido con de snv.\nPhantomJS PhantomJS is un navegador sin interfaz grafica basado en Webkit, aunque la versión en la que se basa es mucho mas antigua que las usadas por Chrome o Safari. A pesar de que históricamente ha sido una elección popular actualmente no es una elección muy sabia. Ya que el proyecto esta sin soporte desde el 5 de gosto, cuando Google anunció que Chrome tendría la capacidad de ser un navegador sin interfaz grafica, algo que también ha ofrecido Firefox.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/on_test_automation/",
	"title": "Sobre automatización de pruebas",
	"tags": [],
	"description": "",
	"content": " Primero, pregúntate si realmente necesitas o no usar un navegador. Lo más probable es que, en algún momento, si estás trabajando en una aplicación web compleja, necesitarás abrir un navegador y realmente probarlo.\nSin embargo, las pruebas funcionales de usuario final, como las pruebas de Selenium son caras de ejecutar. Además, normalmente requieren que una infraestructura considerable este disponible para estas ejecutarse de manera efectiva. Es una buena regla preguntarse siempre si lo que se quiere probar se puede hacer usando enfoques de prueba más livianos como las pruebas unitarias o con un enfoque de bajo nivel.\nUna vez que hayas tomado la determinación de que estás en el negocio de hacer pruebas en el navegador, y que tengas tu ambiente de Selenium listo para empezar a escribir pruebas, generalmente realizaras alguna combinación de estos tres pasos:\n Preparar los datos Realizar un conjunto discreto de acciones Evaluar los resultados  Querrás mantener estos pasos tan cortos como sea posible; una o dos operaciones deberían ser suficientes la mayor parte del tiempo. La automatización del navegador tiene la reputación de ser \u0026ldquo;frágil\u0026rdquo;, pero en realidad, esto se debe a que los usuarios suelen exigirle demasiado. En capítulos posteriores, volveremos a las técnicas que puedes utilizar para mitigar problemas aparentemente intermitentes en las pruebas, en particular como superar race conditions entre el navegador y WebDriver.\nManteniendo tus pruebas cortas y usando el navegador web solo cuando no tienes absolutamente ninguna alternativa, Puedes tener muchas pruebas con fragilidades muy mínimas.\nUna clara ventaja de las pruebas de Selenium es su capacidad inherente para probar todos los componentes de la aplicación, desde el backend hasta el frontend, desde la perspectiva del usuario. En otras palabras, aunque las pruebas funcionales pueden ser caras de ejecutar, también abarcan a la vez grandes porciones críticas para el negocio.\nRequisitos de pruebas Como se mencionó anteriormente, las pruebas de Selenium pueden ser costosas de ejecutar. Hasta qué punto, dependerá del navegador en el que estás ejecutando las pruebas, pero históricamente el comportamiento de los navegadores ha variado tanto que a menudo ha sido un objetivo claro realizar pruebas cruzadas contra múltiples navegadores.\nSelenium te permite ejecutar las mismas instrucciones en múltiples navegadores en múltiples sistemas operativos, pero la enumeración de todos los navegadores posibles, sus diferentes versiones y los muchos sistemas operativos en los que se ejecutan se convertirá rápidamente en una misión no trivial.\nIniciemos con un ejemplo Larry ha escrito un sitio web que le permite a los usuarios ordenar unicornios personalizados.\nEl flujo de trabajo principal (que llamaremos el \u0026ldquo;camino feliz\u0026rdquo;) es algo como esto:\n Crea una cuenta Configura el unicornio Agrégalo al carrito de compras Envialo a caja y realiza el pago Dar feedback sobre el unicornio  Sería tentador escribir un gran script de Selenium para realizar todas estas operaciones, muchos lo intentarán. ¡Resiste la tentación! Hacerlo dará como resultado una prueba que a) toma mucho tiempo, b) estará sujeta a algunos problemas comunes relacionados con los problemas de tiempo de representación de la página, y c) es tal que si falla, no te dará un método conciso y \u0026ldquo;fácil de ver\u0026rdquo; para diagnosticar lo que salió mal.\nLa estrategia preferida para probar este escenario sería dividirlo en una serie de pruebas rápidas e independientes, cada una de las cuales tenga una \u0026ldquo;razón\u0026rdquo; para existir.\nSupongamos que deseas probar el segundo paso: Configurando tu unicornio. Realizará las siguientes acciones:\n Crea una cuenta Configura el unicornio  Ten en cuenta que nos estamos saltando el resto de los pasos, probaremos el resto del flujo en otros casos de prueba pequeños y discretos, después de que hayamos terminado con este.\nPara comenzar, debes crear una cuenta. Aquí tienes que tomar algunas decisiones:\n ¿Quieres usar una cuenta existente? ¿Quieres crear una nueva cuenta? ¿Hay alguna propiedad especial de dicho usuario que deba ser tomado en cuenta antes de que comience la configuración?  Independientemente de cómo respondas esta pregunta, la solución es hacer que forme parte del paso de \u0026ldquo;preparar los datos\u0026rdquo; de la prueba. Si Larry ha expuesto una API que te permite a ti (o cualquier persona) crear y actualizar cuentas de usuario, asegúrate de usar eso para responder esta pregunta. Si es posible, debes iniciar el navegador solo después de tener un usuario \u0026ldquo;en la mano\u0026rdquo;, cuyas credenciales pueden iniciar sesión.\nSi cada prueba para cada flujo de trabajo comienza con la creación de una cuenta de usuario, se agregarán muchos segundos a la ejecución de cada prueba. Llamar a una API y hablar con una base de datos son operaciones \u0026ldquo;sin cabeza\u0026rdquo; rápidas, que no requieren el costoso proceso de abrir un navegador, navegar a las páginas correctas, hacer clic y esperar que se envíen los formularios, etc.\nIdealmente, puedes abordar esta fase de configuración en una sola línea de código, que se ejecutará antes de que se inicie cualquier navegador:\nJava Python C# Ruby JavaScript Kotlin // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. User user = UserFactory.createCommonUser(); //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, # pero no tienen configurada la información de pago, ni tienen # privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico # la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas # conocerlos. user = user_factory.create_common_user() #Este método se define en otro lugar. # Inicia sesión como este usuario. # Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que # el método loginAs devuelve el objeto AccountPage, lo que le permite # realizar acciones de AccountPage account_page = login_as(user.get_email(), user.get_password())   // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. User user = UserFactory.CreateCommonUser(); //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, # pero no tienen configurada la información de pago, ni tienen # privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico # la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas # conocerlos. user = UserFactory.create_common_user #Este método se define en otro lugar. # Inicia sesión como este usuario. # Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que # el método loginAs devuelve el objeto AccountPage, lo que le permite # realizar acciones de AccountPage account_page = login_as(user.email, user.password)   // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. var user = userFactory.createCommonUser(); //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. var accountPage = loginAs(user.email, user.password);   // Crea un usuario que tenga permisos de solo lectura--ellos pueden configurar un unicornio, // pero no tienen configurada la información de pago, ni tienen // privilegios administrativos. En el momento en que se crea el usuario, su correo electrónico // la dirección y la contraseña se generan aleatoriamente--ni siquiera necesitas // conocerlos. val user = UserFactory.createCommonUser() //Este método se define en otro lugar.  // Inicia sesión como este usuario. // Iniciar sesión en este sitio te lleva a tu página personal \u0026#34;Mi cuenta\u0026#34;, por lo que // el método loginAs devuelve el objeto AccountPage, lo que le permite // realizar acciones de AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     Como puedes imaginar, la UserFactory puede ampliarse para proporcionar métodos como createAdminUser() y createUserWithPayment(). El punto es, que estas dos líneas de código no te distraigan del propósito final de esta prueba: configurar un unicornio.\nLas complejidades del Modelo Page Object serán discutidas en capítulos posteriores, pero introduciremos el concepto aquí:\nTus pruebas deben estar compuestas de acciones, realizadas desde el punto de vista del usuario, dentro del contexto de las páginas en el sitio web. Estas páginas se almacenan como objetos, que contendrán información específica sobre cómo está compuesta la página web y cómo se realizan las acciones– muy poco de lo que cual debería preocuparte como probador.\n¿Qué tipo de unicornio quieres? Es posible que desees rosa, pero no necesariamente. El morado es muy popular últimamente. ¿Ella necesita gafas de sol? ¿Tatuajes de estrellas? Estas elecciones, aunque difíciles, son tu principal preocupación como probador: debes asegurarte de que tu centro de distribución de pedidos envíe el unicornio correcto a la persona correcta, y eso comienza con estas elecciones.\nObserva que en ninguna parte de este párrafo hablamos de botones, campos, menús desplegables, botones de opción o formularios web. ¡Tampoco deberían tus pruebas! Debes escribir tu código como el usuario que intenta resolver su problema. Aquí hay una forma de hacerlo (continuando con el ejemplo anterior):\nJava Python C# Ruby JavaScript Kotlin // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. # Esto solo almacena los valores; no llena ningún formulario web ni interactúa # con el navegador de ninguna manera. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al # lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; # nos llevará allí. add_unicorn_page = account_page.add_unicorn() # Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a # su método createUnicorn(). Este método tomará los atributos de Sparkles # completara el formulario y hará clic en enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. # Esto solo almacena los valores; no llena ningún formulario web ni interactúa # con el navegador de ninguna manera. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, Unicor sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al # lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; # nos llevará allí. add_unicorn_page = account_page.add_unicorn # Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a # su método createUnicorn(). Este método tomará los atributos de Sparkles # completara el formulario y hará clic en enviar. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí. var addUnicornPage = accountPage.addUnicorn(); // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar.. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // El Unicornio es un Objeto de nivel superior--tiene atributos, que se establecen aquí. // Esto solo almacena los valores; no llena ningún formulario web ni interactúa // con el navegador de ninguna manera. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Dado que ya estamos \u0026#34;en\u0026#34; la página de la cuenta, tenemos que usarla para acceder al // lugar especifico donde configuras unicornios. Llamar al método \u0026#34;Agregar unicornio\u0026#34; // nos llevará allí.. val addUnicornPage = accountPage.addUnicorn() // Ahora que estamos en la página AddUnicornPage, pasaremos el objeto \u0026#34;sparkles\u0026#34; a // su método createUnicorn(). Este método tomará los atributos de Sparkles, // completara el formulario y hará clic en enviar. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Ahora que has configurado tu unicornio, debes avanzar al paso 3: asegurarte de que realmente funcionó.\nJava Python C# Ruby JavaScript Kotlin // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. Assert.assertTrue(\u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;, unicornConfirmationPage.exists(sparkles));   # El método exist() de UnicornConfirmationPage tomará el objeto # Sparkles--una especificación de los atributos que deseas ver, y los va a comparar # con los campos en la página. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;   // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;);   # El método exist() de UnicornConfirmationPage tomará el objeto # Sparkles--una especificación de los atributos que deseas ver, y los va a comparar # con los campos en la página. expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles debe haberse creado, con todos los atributos intactos\u0026#39;   // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;);   // El método exist() de UnicornConfirmationPage tomará el objeto // Sparkles--una especificación de los atributos que deseas ver, y los va a comparar // con los campos en la página. assertTrue(\u0026#34;Sparkles debe haberse creado, con todos los atributos intactos\u0026#34;, unicornConfirmationPage.exists(sparkles))     Ten en cuenta que el probador aún no ha hecho nada más que hablar de unicornios en este código\u0026ndash; nada de botones, nada de localizadores, nada de controles del navegador. Este método de modelar la aplicación te permite mantener estos comandos de nivel-de-prueba en su lugar y sin cambios, incluso si Larry decide la próxima semana que ya no le gusta Ruby-on-Rails y decide volver a implementar todo el sitio en las últimas librerías de enlace de Haskell con un front-end de Fortran.\nLos objetos de tu página requerirán un pequeño mantenimiento para poder cumplir con el rediseño del sitio, pero estas pruebas seguirán siendo iguales. Tomando este diseño básico, querrás continuar con tus flujos de trabajo con la menor cantidad posible de pasos orientados al navegador. Tu próximo flujo de trabajo implicará agregar un unicornio al carrito de compras. Probablemente querrás muchas iteraciones de esta prueba para asegurarte de que el carrito mantiene su estado correctamente: ¿Hay más de un unicornio en el carrito antes de comenzar? ¿Cuántos pueden caber en el carrito de compras? Si crea más de uno con el mismo nombre y/o características, ¿se romperá? ¿Conservará solo el existente o agregará otro?\nCada vez que te mueves por el flujo de trabajo, deseas evitar tener que crear una cuenta, iniciar sesión como usuario y configurar el unicornio. Idealmente, podrás crear una cuenta y preconfigurar un unicornio a través de la API o de la base de datos. Luego, todo lo que tienes que hacer es iniciar sesión como usuario, ubicar Sparkles, y agrégarla al carrito.\n¿Automatizar o no automatizar? Es la automatización siempre ventajosa? Cuando uno debería decidir automatizar casos de prueba?\nNo siempre es ventajoso automatizar casos de prueba. Hay veces que las pruebas manuales pueden ser mas apropiadas. Por ejemplo, si la interface de usuario de la aplicación va a cambiar considerablemente en el futuro, entonces no habria que reescribir ninguna automatizacion. Tambien, algunas veces simplemente no hay tiempo suficiente para construir la automatización de las pruebas. A corto plazo, las pruebas manuales pueden ser mas efectivas. Si una aplicación tiene una fecha limite muy ajustada, actualmente no hay ningún tipo de automatización de pruebas, y es imperativo que las pruebas se realicen dentro de la fecha limite, entonces las pruebas es la mejor solución.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/working_with_colours/",
	"title": "Trabajando con colores",
	"tags": [],
	"description": "",
	"content": "En algunas ocasiones es posible que sea necesario querer validar el color de algo como parte de tus tests; el problema es que las definiciones de color en la web no son constantes. ¿No estaría bien que existiese una forma sencilla de comparar una representación de color HEX con una representación de color RGB, o una representación de color RGBA con una representación de color HSLA?\nNo te preocupes. Hay una solución para esto, la clase Color\nLo primero de todo, necesitaras importar la clase:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    include Selenium::WebDriver::Support   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    import org.openqa.selenium.support.Color    Ahora puedes empezar a crear objetos de la clase Color. Cada objeto necesita ser creado a partir de la representación de una cadena de texto de tu color.\nLas representaciones de colores soportadas son:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     La clase Color también soporta todas las definiciones base de colores especificadas en http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     En muchas ocasiones los navegadores devolverán un valor de color de transparente si no se ha establecido color en el elemento. La clase Color también soporta esto:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     Ahora puedes consultar de forma segura un elemento para obtener su color/color de fondo sabiendo que cualquier respuesta sera correctamente parseada y convertida en un objeto Color valido.\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)); Color loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;));   login_button_colour = Color.from_string(driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;))   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    login_button_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;)) login_button_background_colour = Color.from_string(driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;))   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    val loginButtonColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;)) val loginButtonBackgroundColour = Color.fromString(driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;))     Puedes comparar objetos de Color directamente:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    assert(login_button_background_colour == HOTPINK)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     También puedes convertir un color en uno de los siguientes formatos y después realizar una validación estática:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     Con todo esto los colores ya no serán un problema.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/remote_webdriver/remote_webdriver_client/",
	"title": "WebDriver remoto - cliente",
	"tags": [],
	"description": "",
	"content": " Para ejecutar un cliente de WebDriver remoto, primero debemos conectarnos a RemoteWebDriver. Hacemos esto apuntando la URL a la dirección del servidor que ejecuta nuestras pruebas. Para personalizar nuestra configuración, establecemos las capabilities deseadas. A continuación se muestra un ejemplo de la, instanciación de un objeto WebDriver remoto apuntando a nuestro servidor web remoto, www.example.com, ejecutando nuestras pruebas en Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Para personalizar aún más nuestra configuración de prueba, podemos agregar otras capabilities deseadas.\nOpciones del navegador Por ejemplo, supón que deseas ejecutar Chrome en Windows XP, usando Chrome versión 67:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;) var capabilities = Capabilities.chrome(); //To avoid InsecureCertificateError for selenium4-aplha5 capabilities.setAcceptInsecureCerts(true); capabilities.set(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); capabilities.set(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     Detector de archivos local El Local File Detector permite la transferencia de archivos desde la máquina del cliente al servidor remoto. Por ejemplo, si una prueba necesita cargar un archivo a una aplicación web, un WebDriver remoto puede transferir automáticamente el archivo de la máquina local al servidor web remoto durante tiempo de ejecución. Esto permite que el archivo se cargue desde la máquina remota ejecutando la prueba. No está habilitado de forma predeterminada y puede habilitarse en de la siguiente manera:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import UselessFileDetector driver.file_detector = UselessFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     Una vez que se definido el código anterior, puedes cargar un archivo en tu prueba de la siguiente manera:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element_by_id(\u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/setting_up_your_own_grid/",
	"title": "Configurando tu propio Grid",
	"tags": [],
	"description": "",
	"content": " Para usar Selenium Grid, necesitas mantener tu propia infraestructura para los nodos. Como esto puede suponer un engorro y suponer un gran esfuerzo de tiempo, muchas organizaciones usan proveedores de IaaS (Infraestructura como servicio) como Amazon EC2 y Google Compute para proveer esta infraestructura.\nOtras opciones incluyen usar proveedores como Sauce Labs or Testing Bot los cuales proveen Selenium Grid como servicio en la nueve. Ciertamente, también es posible ejecutar los nodos en tu propio hardware. Esta capitulo abordara en detalle la opción de ejecutar tu propio Grid completo con su propia infraestructura de nodos.\nInicio rápido Este ejemplo te enseñará como poner en marcha el Grid Hub de Selenium 2 y registrar un nodo WebDriver y un nodo heredado de Selenium 1 RC. También te enseñaremos como llamar al Grid desde Java. El hub y los nodos se muestran aquí ejecutándose en la misma maquina, pero por supuesto puedes copiar selenium-server-standalone en múltiples maquinas.\nEl paquete de selenium-server-standalone incluye el hub, el WebDriver y el servidor RC heredado necesarios para ejecutar el Grid, ant ya no es necesario. Puedes descargar selenium-server-standalone-.jar desde https://selenium.dev/downloads/.\nPaso 1: Iniciar el Hub El Hub es el punto central que recibirá las peticiones de los tests y las distribuirá a los nodos adecuados. La distribución se hace en función capacidades, esto significa que un test que necesite un conjunto de capacidades solo sera distribuido a los nodos que ofrezcan ese conjunto o subconjunto de capacidades.\nDebido a que las capacidades deseadas de una prueba son justo lo que el nombre implica deseadas, el hub no garantiza que se localice un nodo que coincida completamente con el conjunto de capacidades deseadas.\nAbre una ventana de navegación y navega hasta el directorio donde tienes copiado el archivo selenium-server-standalone.jar. Puedes iniciar el hub pasandole el parámetro -role hub al servidor standalone.\njava -jar selenium-server-standalone.jar -role hub El hub escuchará al puerto 4444 por defecto. Puedes ver el estado del hub abriendo una ventana del navegador y navegando a http://localhost:4444/grid/console.\nPara cambiar el puerto por defecto, puedes añadir el parámetro opcional -port asignándole un valor entero que representará el puerto a escuchar cuando se ejecute el comando. Ademas todas las otras opciones que puedes observar en el archivo de configuración JSON (mostrado a continuación) son posibles parámetros vía linea de comandos.\nCiertamente puedes trabajar solo con el comando simple que se muestra arriba, pero si necesitases una configuración mas avanzada podrías especificarla en un archivo de configuración JSON para configurar el hub con su arranque. Puedes hacerlo tal que así.\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug A continuación puedes ver un ejemplo de un archivo hubConfig.json. Iremos mas en detalle sobre como proveer archivos de configuración a los nodos en el paso 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Paso 2: Iniciar los nodos Independientemente de si quieres ejecutar un Grid con una nueva funcionalidad del WebDriver, un Grid con funcionalidades de Selenium 1 RC, o ambas al mismo tiempo se usa el mismo archivo selenium-server-standalone.jar para arrancar los nodos.\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 Si no se especifica un puerto a través del parámetro -port se elegirá un puerto libre. Puedes ejecutar múltiples nodos en una maquina pero si lo haces tienes que tener en cuenta los recursos de memoria de tus sistemas y de los problemas con las capturas de pantalla si tus tests las realizan.\nConfiguración de un nodo con opciones Como hemos mencionado, para disponer de compatibilidad con las versiones anteriores los roles \u0026ldquo;wd\u0026rdquo; y \u0026ldquo;rc\u0026rdquo; todavía son un subconjunto valido del rol en los \u0026ldquo;node\u0026rdquo;. Pero estos roles limitan el tipo de conexiones remotas a sus correspondientes APIs, mientras que el rol \u0026ldquo;node\u0026rdquo; permite conexiones remotas a ambos el RC y al WebDriver.\nPasar propiedades de la JVM (como usar el parámetro -D antes del argumento -jar) vía linea de comando permitirá a las nodos recoger y propagar estos parámetros.\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfigurando un nodo via JSON Tambien se pueden ejecutar nodos que hayan sido configurados via archivos de configuración JSON.\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json Este es un ejemplo de archivo nodeConfig.json:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } Una nota sobre el parametro -host:\nPara ambos el hub y el nodo, si no se especifica el parámetro -host se usará por defecto la IP 0.0.0.0. Este se unirá a todos los interfaces IPv4 públicos (sin loopback) de la maquina. Si tienes alguna configuración de red especial o algún componente que utilice interfaces de red extra es recomendado fijar el parámetro -host con un valor que permita que el hub o los nodos sean accesibles desde maquinas diferentes.\nEspecificando el puerto El puerto TCP/IP por defecto usado por el hub es el 4444. Si necesitas cambiar el puerto por favor usa las configuraciones mencionadas arriba.\nSolución de problemas Usando un archivo log Para resolución de problemas avanzados puedes especificar un archivo de log que almacene los mensajes del sistema. Lanza el Grid de Selenium o el nodo con el argumento -log. A continuación dispone de un ejemplo:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Usa tu editor de texto favorito para abrir el archivo de log (log.txt en el ejemplo) para encontrar los logs de \u0026ldquo;ERROR\u0026rdquo; si tienes problemas.\nUsando el argumento -debug También puedes usar el argumento -debug para imprimir los logs de debug en la consola. Lanza el Grid de Selenium o el nodo con el argumento -debug. A continuación dispone de un ejemplo:\njava -jar selenium-server-standalone.jar -role hub -debug Advertencia El Grid de Selenium debe estar protegido contra accesos externos mediante el uso apropiado de permisos de firewall.\nFallar a la hora de proteger el Grid puede resultar en uno o mas de los siguientes problemas:\n Proveer acceso abierto a tu infraestructura del Grid. Permitir a terceros el acceso a aplicaciones web y archivos interno. Permitir a terceros ejecutar tus ejecutables.  Puedes visitar el blog Detectify el cual te puede aportar mas información sobre los peligros de exponer tu grid públicamente. Aquí puedes visitar el articulo Don\u0026rsquo;t Leave your Grid Wide Open.\nSelenium Docker Docker provee una forma conveniente de aprovisionar y escalar la infraestructura de Selenium Grid en unidades conocidas como contenedores. Los contenedores son unidades estandarizadas de software que contienen todo lo necesario para ejecutar la aplicación deseada, incluidas todas las dependencias, en un entorno confiable y regenerable en diferentes sistemas.\nEl proyecto de Selenium mantiene un conjunto de imágenes Docker las cuales puedes descargar y ejecutar para tener un Grid funcionando rápidamente. Los nodos están disponibles para los navegadores Firefox y Chrome. Todos los detalles de como abastecer un Grid se encuentran en Docker Selenium.\nPrerequisitos El único requisito para ejecutar el Grid es tener Docker instalado y funcionando. Puedes descargar Docker en este enlace.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/http_response_codes/",
	"title": "Códigos de respuesta HTTP",
	"tags": [],
	"description": "",
	"content": "Para algunas configuraciones de navegadores en Selenium RC, Selenium actuaba como proxy entre el navegador y el sitio web que iba a ser automatizado. Esto significaba que todo el trafico que pasaba a través de Selenium podía ser capturado o manipulado. El método captureNetworkTraffic() pretendía capturar todo el trafico de red entre el navegador y el sitio que estaba siendo automatizado, incluyendo los códigos de respuestas HTTP.\nEl WebDriver de Selenium parte de una aproximación completamente diferente respecto a la automatización de los navegadores, prefiriendo así actuar mas como un usuario y esto se representa en la forma en la que escribes los tests con el WebDriver. Para los tests funcionales automatizados comprobar el código de respuesta no es un detalle particularmente importante en un test fallido, los pasos que se han realizado lo son mucho mas.\nEl navegador siempre representará el código de estado de respuesta HTTP, imagina por ejemplo una pagina de error para los códigos 404 o 500. Un forma simple de hacer fallar el test cuando encuentras una de estas paginas de error es validar los títulos de las paginas o algún contenido de confianza (ej. la etiqueta \u0026lt;h1\u0026gt;) después de que se haya cargado cada pagina. Si estas usando un modelo basado en el patrón page object puedes incluir esta validación en el constructor de la clase o en puntos similares donde se espere la carga de una pagina. En algunas ocasiones el código de respuesta HTTP puede llegar a ser representado en la pagina de error en el navegador e incluso podrías usar el WebDriver para leerlo y facilitar la depuración en tus tests.\nComprobar la pagina web es la linea de trabajo ideal del WebDriver representando y validando así la vista de los usuarios de los sitios web.\nSi aun así necesitases una forma de capturar los códigos de respuesta HTTP una forma avanzada es replicar el comportamiento de Selenium RC usando un proxy. El API del WebDriver provee la habilidad de configurar un proxy para un navegador, existen una gran cantidad de proxies que te permiten programaticamente manipular los contenidos de las peticiones enviadas y recibidas desde los servidores web. Usar un proxy te permite decidir como actuar frente a redirecciones. Ademas, no todos los navegadores hacen que los códigos de respuesta estén disponibles para el WebDriver, es por eso que optar por un proxy te permitirá disponer de una solución común para todos los navegadores.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/generating_application_state/",
	"title": "Generar el estado de la aplicación",
	"tags": [],
	"description": "",
	"content": "Selenium no debe usarse para preparar un caso de prueba. Todas las acciones repetitivas y los preparativos para un caso de prueba deben realizarse a través de otros métodos. Por ejemplo, la mayoría de las IU web tienen autenticación (por ejemplo, un formulario de inicio de sesión). Eliminar el inicio de sesión a través del navegador web antes de cada prueba mejora tanto la velocidad como la estabilidad de la prueba. Un método debe ser creado para obtener acceso al AUT* (por ejemplo, usando una API para iniciar sesión y establecer un cookie). Además, crear métodos para precargar datos para las pruebas no deben realizarse con Selenium. Como se mencionó previamente, las API existentes se deben aprovechar para crear datos para el AUT*.\n*AUT: Application Under Test (aplicación bajo prueba)\n"
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/html-runner/",
	"title": "HTML runner",
	"tags": [],
	"description": "",
	"content": " Selenium HTML-runner te permite ejecutar Test Suites desde una línea de comando. Las suites de prueba son exportaciones HTML de Selenium IDE o herramientas de compatibles.\nInformación común  Combinaciónes de versiones de geckodriver / firefox / selenium-html-runner importan. Puede haber una matriz de compatibilidad de software en alguna parte. selenium-html-runner solo ejecuta Test Suites (no Test Cases - por ejemplo, una exportación desde Monitis Transaction Monitor). Asegurate que cumples con esto. Para usuarios de Linux sin INTERFAZ: debes iniciar html-runner con pantalla virtual (buscar xvfb)  Ejemplo en un ambiente Linux Instala / descarga los siguientes paquetes de software:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Ejemplo de Test Suite:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Como ejecutar headless (sin interfaz visual) selenium-html-runner Ahora, la parte más importante, un ejemplo de cómo ejecutar el selenium-html-runner! Tu experiencia puede variar según combinaciones de las versiones del software - geckodriver / FF / html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html[user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt;"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/",
	"title": "Instalación de Selenium",
	"tags": [],
	"description": "",
	"content": " Instalación de Selenium La configuración de Selenium es bastante diferente de la configuración de otras herramientas comerciales. Para usar Selenium en tu proyecto de automatización, necesitas instalar las librerías de enlace de tu lenguaje de preferencia. Además necesitarás los binarios de WebDriver para los navegadores en los que deseas automatizar y ejecutar pruebas.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/selenium_installation/installing_standalone_server/",
	"title": "Instalación del servidor Standalone",
	"tags": [],
	"description": "",
	"content": "Si planeas usar Grid debes descargar el fichero selenium-server-standalone JAR. Todos los componentes están disponibles a través de selenium-server. El standalone JAR contiene todo, incluso el servidor remoto de Selenium y los enlaces del lado del cliente. Ésto quiere decir que si usas el selenium-server-standalone jar en tu proyecto, no tienes que añadir selenium-java o un jar de navegador específico.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/locating_elements/",
	"title": "Localizando elementos",
	"tags": [],
	"description": "",
	"content": " Localizando un elemento Una de las técnicas más fundamentales para aprender al usar WebDriver es cómo encontrar elementos en la página. WebDriver ofrece varios tipos de selectores integrados, entre ellos encontrar un elemento por su atributo ID:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;));   driver.find_element_by_id(\u0026#34;cheese\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     Como se ve en el ejemplo, localizar elementos en WebDriver se realiza en la instancia del objeto WebDriver. El método findElement(By) devuelve otro tipo de objeto fundamental, el WebElement.\n WebDriver representa el navegador WebElement representa un nodo particular del DOM (un control, por ejemplo un enlace o campo de entrada, etc.)  Una vez que tengas una referencia a un elemento web que se ha \u0026ldquo;encontrado\u0026rdquo;, puedes reducir el alcance de tu búsqueda utilizando la misma llamada en la instancia de ese objeto:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)); WebElement cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element_by_id(\u0026#34;cheese\u0026#34;) cheddar = cheese.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement cheese = driver.FindElement(By.Id(\u0026#34;cheese\u0026#34;)); IWebElement cheddar = cheese.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;) cheddar = cheese.find_element(id: \u0026#39;cheddar\u0026#39;)   const cheese = driver.findElement(By.id(\u0026#39;cheese\u0026#39;)); const cheddar = cheese.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     Puedes hacer esto porque los tipos WebDriver y WebElement implementan la interfaz SearchContext. En WebDriver, esto se conoce como interfaz basada en roles. Las interfaces basadas en roles te permiten determinar si la implementación del controlador admite una característica dada. Estas interfaces están claramente definidas y tratan de cumplir con tener un solo rol de responsabilidad. Puede leer más sobre el diseño de WebDriver y qué roles son compatibles con qué controladores en Otra sección. En consecuencia, la interfaz By utilizada anteriormente también permite una serie de estrategias adicionales de localización. Una búsqueda anidada podría no ser la estrategia mas efectiva para localizar cheese ya que requiere dos comandos que se emitirán al navegador; primero buscando en el DOM un elemento con ID \u0026ldquo;cheese\u0026rdquo;, luego una búsqueda de \u0026ldquo;cheddar\u0026rdquo; en un contexto reducido.\nPara mejorar ligeramente el rendimiento, deberíamos intentar utilizar un localizador más específico: WebDriver permite buscar elementos por localizadores CSS, lo que nos permite combinar los dos localizadores anteriores en una sola búsqueda:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#cheese #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#cheese #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#cheese #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#cheese #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     Localizando múltiples elementos Es posible que el documento con el que estamos trabajando contenga una lista ordenada del queso que más nos gusta:\n\u0026lt;ol id=cheese\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Dado que más queso es indiscutiblemente mejor, y sería engorroso tener que recuperar cada uno de los elementos individualmente, una técnica superior para recuperar cheese es hacer uso de la versión pluralizada findElements(By). Este método devuelve una colección de elementos web. Si solo se encuentra un elemento, aún devolverá una colección (de un elemento). Si ningún elemento coincide con el localizador, se devolverá la lista vacía. Java Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; muchoCheese = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;));   mucho_cheese = driver.find_elements_by_css_selector(\u0026#34;#cheese li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; muchoCheese = driver.FindElements(By.CssSelector(“#cheese li”));   mucho_cheese = driver.find_elements(css: \u0026#39;#cheese li\u0026#39;)   const muchoCheese = driver.findElements(By.css(\u0026#39;#cheese li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))    \nEstrategias de localización de elementos Hay ocho estrategias diferentes de ubicación de elementos integradas en WebDriver:\n   Localizador Descripción     class name Localiza elementos en el que el nombre de su clase contiene el valor de la búsqueda (no se permiten nombres de clase compuestos)   css selector Localiza elementos que coinciden con un selector CSS   id Localiza elementos cuyo atributo ID coincide con el valor de la búsqueda   name Localiza elementos cuyo atributo NAME coincide con el valor de la búsqueda   link text Localiza elementos de anclaje cuyo texto visible coincide con el valor de búsqueda   partial link text Localiza elementos de anclaje cuyo texto visible coincide con el valor de búsqueda. Si varios elementos coinciden, solo se seleccionará el primero.   tag name Localiza elementos cuyo nombre de etiqueta (tagName) coincide con el valor de búsqueda   xpath Localiza elementos que coinciden con una expresión XPath    Consejos sobre el uso de selectores En general, si los ID del HTML están disponibles, son únicos y consistentemente predecibles, son el método preferido para ubicar un elemento en una página. Tienden a trabajar muy rápido y renuncian al mucho procesamiento que viene con recorridos DOM complicados.\nSi las ID únicas no están disponibles, un selector CSS bien escrito es el método preferido para localizar un elemento. XPath funciona tan bien como los selectores CSS, pero la sintaxis es complicada y con frecuencia difícil de depurar. Aunque los selectores XPath son muy flexibles, generalmente su desempeño no es probado por lo proveedores de navegadores y tienden a ser bastante lentos.\nLas estrategias de selección basadas en enlaces de texto y enlaces de texto parciales tienen el inconveniente en que solo funcionan en elementos de enlace. Además, internamente en WebDriver llaman a los selectores XPath.\nEl nombre de la etiqueta puede ser una forma peligrosa de localizar elementos. Existen frecuentemente múltiples elementos con la misma etiqueta presentes en la página. Esto es mayormente útil cuando se llama al método findElements(By) que devuelve una colección de elementos.\nLa recomendación es mantener tus localizadores tan compactos y legibles como sea posible. Pedirle a WebDriver que atraviese la estructura del DOM es una operación costosa, y cuanto más se pueda reducir el alcance de tu búsqueda, mejor.\nRelative Locators Selenium 4 brings Relative Locators which are previously called as Friendly Locators. This functionality was added to help you locate elements that are nearby other elements. The Available Relative Locators are:\n above below toLeftOf toRightOf near  findElement method now accepts a new method withTagName() which returns a RelativeLocator.\nHow does it work Selenium uses the JavaScript function getBoundingClientRect() to find the relative elements. This function returns properties of an element such as right, left, bottom, and top.\nabove() Returns the WebElement, which appears above to the specified element\nJava Python C# Ruby JavaScript Kotlin // Please raise a pr    # Please raise a PR   // Please raise a PR    # Please raise a PR   // Please raise a PR    // Please raise a PR      below() Returns the WebElement, which appears below to the specified element\nJava Python C# Ruby JavaScript Kotlin // Please raise a pr    # Please raise a PR   // Please raise a PR    # Please raise a PR   // Please raise a PR    // Please raise a PR      toLeftOf() Returns the WebElement, which appears to left of specified element\nJava Python C# Ruby JavaScript Kotlin // Please raise a pr    # Please raise a PR   // Please raise a PR    # Please raise a PR   // Please raise a PR    // Please raise a PR      toRightOf() Returns the WebElement, which appears to right of the specified element\nJava Python C# Ruby JavaScript Kotlin // Please raise a pr    # Please raise a PR   // Please raise a PR    # Please raise a PR   // Please raise a PR    // Please raise a PR      near() Returns the WebElement, which is at most 50px away from the specified element.\nJava Python C# Ruby JavaScript Kotlin // Please raise a pr    # Please raise a PR   // Please raise a PR    # Please raise a PR   // Please raise a PR    // Please raise a PR      "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/browser_manipulation/",
	"title": "Manipulación de Navegadores",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.getCurrentUrl();    Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward();    Refresh Refresh the current page:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.getTitle()    Windows and tabs Get window handle WebDriver does not make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.getWindowHandle()    Switching windows or tabs Clicking a link which opens in a new window will focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nHowever, Selenium 4 provides a new api NewWindow  which creates a new tab (or) new window and automatically switches to it.\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element_by_link_text(\u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Create new window (or) new tab and switch Creates a new window (or) tab and will focus the new window or tab on screen. You don\u0026rsquo;t need to switch to work with the new window (or) tab. If you have more than two windows (or) tabs opened other than the new window, you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB); // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW);   # Opens a new tab and switches to new tab driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Opens a new window and switches to new window driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Opens a new tab and switches to new tab driver.SwitchTo().NewWindow(WindowType.Tab) // Opens a new window and switches to new window driver.SwitchTo().NewWindow(WindowType.Window)   # Note: The new_window in ruby only opens a new tab (or) Window and will not switch automatically # The user has to switch to new tab (or) new window # Opens a new tab and switches to new tab driver.manage.new_window(:tab) # Opens a new window and switches to new window driver.manage.new_window(:window)   // Opens a new tab and switches to new tab await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Opens a new window and switches to new window await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB) // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW)     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Quit will:  Close all the windows and tabs associated with that WebDriver session Close the browser process Close the background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)   Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # unittest teardown # https://docs.python.org/3/library/unittest.html?highlight=teardown#unittest.TestCase.tearDown def tearDown(self): self.driver.quit()   /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # UnitTest Teardown # https://www.rubydoc.info/github/test-unit/test-unit/Test/Unit/TestCase def teardown @driver.quit end   /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, WebDriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it wasn\u0026rsquo;t for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element_by_css_selector(\u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().getSize().getWidth() val height = driver.manage().window().getSize().getHeight() //Or store the dimensions and query them later val size = driver.manage().window().getSize() val width1 = size.getWidth() val height1 = size.getHeight()     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size(Dimension(1024, 768))   \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   #Access each dimension individually x = driver.manage.window.position.x y = driver.manage.window.position.y # Or store the dimensions and query them later rect = driver.manage.window.rect x1 = rect.x y1 = rect.y   // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x int y1 = position.y     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     Maximise window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Minimize window Minimizes the window of current browsing context. The exact behavior of this command is specific to individual window managers.\nMinimize Window typically hides the window in the system tray.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().minimize();  driver.minimize_window()  driver.Manage().Window.Minimize();   driver.manage.window.minimize  await driver.manage().window().minimize();   driver.manage().window().minimize()    Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/types_of_testing/",
	"title": "Tipos de pruebas",
	"tags": [],
	"description": "",
	"content": " Pruebas de aceptación Este tipo de prueba se realiza para determinar si una funcionalidad o un sistema cumple con las expectativas y requerimientos del cliente. Este tipo de pruebas generalmente implican la cooperación o retroalimentación del cliente, siendo una actividad de validación que responde la pregunta: \u0026gt;¿Estamos construyendo el producto correcto?.\nPara aplicaciones web, la automatización de esta prueba se puede hacer directamente con Selenium simulando el comportamiento esperado del usuario. Esta simulación podría hacerse mediante grabación/ reproducción o mediante los diferentes lenguajes soportados como se explica en esta documentación. Nota: Las pruebas de aceptación son un subtipo de pruebas funcionales, a lo que algunas personas también podrían referirse.\nPruebas funcionales Este tipo de prueba se realiza para determinar si una funcionalidad o sistema funciona correctamente y sin problemas. Se comprueba el sistema en diferentes niveles para garantizar que todos los escenarios están cubiertos y que el sistema hace lo que se supone que debe de hacer. Es una actividad de verificación que responde la pregunta: \u0026gt;¿Estamos construyendo el producto correctamente?.\nPara aplicaciones web, la automatización de esta prueba puede ser hecha directamente con Selenium simulando los retornos esperados. Esta simulación podría hacerse mediante grabación/reproducción o mediante los diferentes lenguajes soportados como se explica en esta documentación.\nPruebas de rendimiento Como su nombre indica, se realizan pruebas de rendimiento para medir qué tan bien está funcionando una aplicación.\nHay dos subtipos principales para las pruebas de rendimiento:\nPruebas de carga La prueba de carga se realiza para verificar qué tan bien la aplicación funciona bajo diferentes cargas definidas ( generalmente un número particular de usuarios conectados a la vez).\nPruebas de estrés Se realizan pruebas de estrés para verificar qué tan bien la aplicación funciona bajo estrés (o por encima de la carga máxima soportada).\nEn general, las pruebas de rendimiento se realizan ejecutando algunas pruebas de Selenium que simulan diferentes usuarios golpeando una función particular en la aplicación web y obteniendo algunas medidas significativas.\nEn general, esto lo hacen otras herramientas que obtienen las métricas. Una de esas herramientas es JMeter.\nPara una aplicación web, los detalles a medir incluyen rendimiento, latencia, pérdida de datos, tiempos de carga de componentes individuales\u0026hellip;\nNota 1: Todos los navegadores tienen una pestaña de rendimiento en su sección de herramientas para desarrolladores (accesible presionando F12)\nNota 2: es un subtipo de pruebas no funcionales ya que esto generalmente se mide por sistema y no por función/funcionalidad.\nPruebas de regresión Esta prueba generalmente se realiza después de un cambio, corrección o adición de funcionalidad.\nPara garantizar que el cambio no ha roto ninguna de las funcionalidades existentes, algunas pruebas ya ejecutadas se ejecutan nuevamente.\nEl conjunto de pruebas ejecutadas nuevamente puede ser total o parcial, y puede incluir varios tipos diferentes, dependiendo del equipo de desarrollo y la aplicación.\nDesarrollo guiado por pruebas (TDD) En lugar de un tipo de prueba per se, TDD es una metodología iterativa de desarrollo en la que las pruebas guían el diseño de una funcionalidad.\nCada ciclo comienza creando un conjunto de pruebas unitarias que la funcionalidad debería pasar finalmente (deberían fallar la primera vez que se ejecuta).\nDespués de esto, se lleva a cabo el desarrollo para pasar las pruebas. Las pruebas se ejecutan nuevamente, comenzando otro ciclo y este proceso continúa hasta que todas las pruebas pasen.\nEl objetivo es acelerar el desarrollo de una aplicación basado en el hecho de que los defectos son menos costosos cuanto más antes se encuentran.\nDesarrollo guiado por comportamiento (BDD) BDD es también una metodología de desarrollo iterativo basado en el TDD anterior, en el que el objetivo es involucrar todas las partes en el desarrollo de una aplicación.\nCada ciclo comienza creando algunas especificaciones (que deberían fallar). Luego creando las pruebas unitarias fallidas (que también deberían fallar) y luego hacer el desarrollo.\nEste ciclo se repite hasta que pasan todos los tipos de pruebas.\nPara realizar esto, se usa un lenguaje de especificación. Debe ser simple y entendible por todas las partes, estándar y explícito. La mayoría de las herramientas usan Gherkin como este lenguaje.\nEl objetivo es poder detectar aún más errores que TDD, apuntando también a posibles errores de aceptación y a facilitar la comunicación entre las partes.\nActualmente hay un conjunto de herramientas disponibles para escribir las especificaciones y relacionarlas con funciones de código, como Cucumber o SpecFlow.\nUn conjunto de herramientas se han construido encima de Selenium para realizar este proceso aún más rápido al transformar directamente las especificaciones de BDD en código ejecutable. Algunas de estas son JBehave, Capybara y Robot Framework.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/working_with_select_elements/",
	"title": "Trabajando con elementos select",
	"tags": [],
	"description": "",
	"content": "A la hora de seleccionar elementos puede ser necesario código repetitivo para poder ser automatizado. Para reducir esto y hacer tus test mas limpios, existe un clase Select en los paquetes de soporte de Selenium. Para usarla, necesitarás importarla de la siguiente forma:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    import org.openqa.selenium.support.ui.Select     Una vez importado, ya podrás crear un objeto Select usando un WebElement que referencie a un elemento \u0026lt;select\u0026gt;.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element_by_id(\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     El objeto Select te proporcionará una serie de comandos que te permitirán interactuar con los elementos \u0026lt;select\u0026gt;. Lo primero de todo, existen diferentes formas de seleccionar una opción de un elemento \u0026lt;select\u0026gt;.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; Existen tres formas de seleccionar la primera opción del ejemplo que se muestra arriba.\nJava Python C# Ruby JavaScript Kotlin // Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; selectObject.selectByIndex(1); // Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; select_object.select_by_index(1) # Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value select_object.select_by_value(\u0026#39;value1\u0026#39;) # Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; selectObject.SelectByIndex(1); // Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; select_object.select_by(:index, 1) # Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Selecciona una \u0026lt;option\u0026gt; basándose en el indice interno del elemento \u0026lt;select\u0026gt; selectObject.selectByIndex(1) // Selecciona una \u0026lt;option\u0026gt; basándose en su atributo value selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Selecciona una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     Puedes revisar que opciones están seleccionadas usando:\nJava Python C# Ruby JavaScript Kotlin // Devuelve una Lista de \u0026lt;WebElements\u0026gt; con las opciones que han sido seleccionadas List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Devuelve una Lista de [WebElements] con las opciones que han sido seleccionadas all_selected_options = select_object.all_selected_options # Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM first_selected_option = select_object.first_selected_option   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    # Devuelve un Array de \u0026lt;WebElements\u0026gt; con las opciones que han sido seleccionadas all_selected_options = select_object.selected_options # Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM first_selected_option = select_object.first_selected_option   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Devuelve una Lista de \u0026lt;WebElements\u0026gt; con las opciones que han sido seleccionadas val allSelectedOptions = selectObject.allSelectedOptions // Devuelve un WebElement que referencia a la primera opción seleccionada que se encontró en el DOM val firstSelectedOption = selectObject.firstSelectedOption     Tambien existe una forma de obtener que elementos \u0026lt;option\u0026gt; contiene un \u0026lt;select\u0026gt;:\nJava Python C# Ruby JavaScript Kotlin // Devuelve una lista de \u0026lt;WebElements\u0026gt; que contiene las opciones de un elemento \u0026lt;select\u0026gt; List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Devuelve una lista de [WebElements] que contiene las opciones de un elemento \u0026amp;lt;select\u0026amp;gt; all_available_options = select_object.options   // Devuelve una IList de \u0026lt;IWebElements\u0026gt; que contiene las opciones de un elemento \u0026lt;select\u0026gt; IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Devuelve un array de [WebElements] que contiene las opciones de un elemento \u0026amp;lt;select\u0026amp;gt; all_available_options = select_object.options   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Devuelve una lista de \u0026lt;WebElements\u0026gt; que contiene las opciones de un elemento \u0026lt;select\u0026gt; val allAvailableOptions = selectObject.options     A la hora de deseleccionar elementos dispones de cuatro opciones:\nJava Python C# Ruby JavaScript Kotlin // Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; selectObject.deselectByIndex(1); // Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados selectObject.deselectAll();   # Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; select_object.deselect_by_index(1) # Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados select_object.deselect_all()   // Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; selectObject.DeselectByIndex(1); // Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados selectObject.DeselectAll();   # Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; select_object.deselect_by(:index, 1) # Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados select_object.deselect_all   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    // Deseleccionar una \u0026lt;option\u0026gt; basándose en el indice interno de un elemento \u0026lt;select\u0026gt; selectObject.deselectByIndex(1) // Deseleccionar una \u0026lt;option\u0026gt; basándose en su atributo `value` selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deseleccionar una \u0026lt;option\u0026gt; basándose en el texto que muestra selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deseleccionar todos los elementos \u0026lt;option\u0026gt; que estan seleccionados selectObject.deselectAll()     Finalmente, existen algunos elementos \u0026lt;select\u0026gt; que te permiten seleccionar mas de una opción. Puedes comprobar si tu elemento \u0026lt;select\u0026gt; es uno de estos usando:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // No disponemos del ejemplo de código en Javascript aun - Ayudanos a ello abriendo un PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "Acciones del ratón en detalle",
	"tags": [],
	"description": "",
	"content": " El ratón representa eventos del ratón. Las acciones del ratón son realizadas a través de una interfaz de bajo nivel la cual nos permite introducir acciones de dispositivos virtualizados al navegador web.\nclickAndHold Moverá el ratón al elemento y hará clic (sin soltar) en medio del elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción click-and-hold en el elemento  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; searchBtn = driver.find_element_by_link_text(\u0026#34;Sign in\u0026#34;) # Realiza la acción click-and-hold en el elemento webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción click-and-hold en el elemento  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Realiza la acción click-and-hold en el elemento driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción click-and-hold en el elemento  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción click-and-hold en el elemento  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick Este método en primer lugar realiza un movimiento del ratón a la localización del elemento y realiza un clic contextual (clic derecho) en el elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción context-click en el elemento  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; searchBtn = driver.find_element_by_link_text(\u0026#34;Sign in\u0026#34;) # Realiza la acción context-click en el elemento webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción context-click en el elemento  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Realiza la acción context-click en el elemento driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción context-click en el elemento  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción context-click en el elemento  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick Moverá el ratón al elemento y realizará un clic doble en medio del elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción double-click en el elemento  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; searchBtn = driver.find_element_by_link_text(\u0026#34;Sign in\u0026#34;) # Realiza la acción double-click en el elemento webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción double-click en el elemento  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del botón \u0026#39;Sign in\u0026#39; sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Realiza la acción double-click en el elemento driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción double-click en el elemento  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del botón \u0026#39;Sign in\u0026#39;  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción double-click en el elemento  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement Este método mueve el ratón en medio del elemento dado. El elemento ademas es desplazado hacia la vista al realizar la acción.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción move hacia el elemento  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmailLink = driver.find_element_by_link_text(\u0026#34;Gmail\u0026#34;) # Realiza la acción move hacia el elemento webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción move hacia el elemento  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Realiza la acción move hacia el elemento driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción move hacia el elemento  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción move hacia el elemento  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset: Este método mueve el ratón desde su posición actual (o desde 0,0) hasta un desplazamiento dado. Si las coordenadas están fuera de la vista de la ventana, entonces el ratón terminará fuera de la ventana del navegador.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Captura el desplazamiento de las posiciones x e y del elemento  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Realiza la acción move hacia la posición del desplazamiento  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.google.com\u0026#34;) # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmailLink = driver.find_element_by_link_text(\u0026#34;Gmail\u0026#34;) # Captura el desplazamiento de las posiciones x e y del elemento xOffset = 100 yOffset = 100 # Realiza la acción move hacia la posición del desplazamiento webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Captura el desplazamiento de las posiciones x e y del elemento  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Realiza la acción move hacia la posición del desplazamiento  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.google.com\u0026#39; # Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39; gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Captura el desplazamiento de las posiciones x e y del elemento x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Realiza la acción move hacia la posición del desplazamiento driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Captura el desplazamiento de las posiciones x e y del elemento  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Realiza la acción move hacia la posición del desplazamiento  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://google.com\u0026#34;) // Guarda el elemento web del enlace \u0026#39;Gmail\u0026#39;  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Captura el desplazamiento de las posiciones x e y del elemento  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Realiza la acción move hacia la posición del desplazamiento  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop Este método en primer lugar realiza una acción click-and-hold en el elemento de origen, después lo mueve a la localización del elemento de destino y por ultimo suelta el clic.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción dragAndDrop desde el origen hacia el destino  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen sourceEle = driver.find_element_by_id(\u0026#34;draggable\u0026#34;) # Guarda \u0026#39;targetEle\u0026#39; como elemento de destino targetEle = driver.find_element_by_id(\u0026#34;droppable\u0026#34;) # Realiza la acción dragAndDrop desde el origen hacia el destino webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Realiza la acción dragAndDrop desde el origen hacia el destino  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Guarda \u0026#39;source_ele\u0026#39; como elemento de origen source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Guarda \u0026#39;target_ele\u0026#39; como elemento de destino target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Realiza la acción dragAndDrop desde el origen hacia el destino driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Realiza la acción dragAndDrop desde el origen hacia el destino  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Realiza la acción dragAndDrop desde el origen hacia el destino  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy Este metodo en primer lugar realiza un click-and-hold en el elemento origen, mueve el ratón al desplacamiento dado y luego suelta el raton.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen sourceEle = driver.find_element_by_id(\u0026#34;draggable\u0026#34;) # Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas targetEle = driver.find_element_by_id(\u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Realiza la acción de dragAndDropBy hacia el desplazamiento destino webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Guarda \u0026#39;source_ele\u0026#39; como elemento de origen source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Guarda \u0026#39;target_ele\u0026#39; como elemento de destino y obtiene las coordenadas x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Realiza la acción de dragAndDropBy hacia el desplazamiento destino driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino y obtiene las coordenadas  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Realiza la acción de dragAndDropBy hacia el desplazamiento destino  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release Esta acción suelta el botón izquierdo del ratón. Si se le pasa un WebElement, soltará el botón izquierdo del ratón en el elemento dado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Realiza la acción release  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen sourceEle = driver.find_element_by_id(\u0026#34;draggable\u0026#34;) # Guarda \u0026#39;targetEle\u0026#39; como elemento de destino targetEle = driver.find_element_by_id(\u0026#34;droppable\u0026#34;) webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() # Realiza la acción release webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Realiza la acción release  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Realiza la acción release driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Realiza la acción release  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navega a la URL  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Guarda \u0026#39;sourceEle\u0026#39; como elemento de origen  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) //Guarda \u0026#39;targetEle\u0026#39; como elemento de destino  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Realiza la acción release  actionProvider.release().build().perform() } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/es/introduction/about_this_documentation/",
	"title": "Acerca de esta documentación",
	"tags": [],
	"description": "",
	"content": "Estos documentos, como el código en sí, son mantenidos al 100% por voluntarios dentro de la comunidad de Selenium. Muchos lo han estado usando desde su inicio, pero muchos más lo han estado usando desde hace poco y han dado su tiempo para ayudar a mejorar la experiencia de iniciación para los nuevos usuarios.\nSi hay un problema con la documentación, ¡queremos saberlo! La mejor manera de comunicar un problema es visitar https://github.com/seleniumhq/seleniumhq.github.io/issues y buscar para ver si el problema ya se ha archivado o no. Si no, ¡no dudes en abrir uno!\nMuchos miembros de la comunidad frecuentan el canal IRC #selenium en irc.freenode.net. ¡No dude en venir y hacer preguntas y si obtiene ayuda que cree que podría ser útil en estos documentos, asegúrese de agregar su contribución! Podemos actualizar estos documentos, pero es mucho más fácil para todos cuando recibimos contribuciones de fuera de los encargados normales.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Autenticarse con Gmail, email y Facebook",
	"tags": [],
	"description": "",
	"content": "Por múltiples razones, autenticarse en sitios como Gmail y Facebook usando el WebDriver no esta recomendado. Aparte de estar en contra de los términos y condiciones de estos sitios (te expones a que te cierren la cuenta), es un proceso lento y poco fiable.\nLa practica ideal respecto a estos los sitios de emails es usar las APIs que ofrecen, en el caso de Facebook usar las herramientas para desarrolladores las cuales exponen un API para crear cuentas de prueba, amigos, etc. A pesar de que usar un API puede parecer como un esfuerzo extra, lo recuperarás en velocidad, fiabilidad y estabilidad. Ademas el API tiene muy pocas probabilidades de cambiar mientras que las paginas web y los elementos HTML cambian frecuentemente y requieren actualizar tu framework de pruebas constantemente.\nAutenticarse en sitios de terceros usando el WebDriver en cualquier punto de tus tests incrementa el riesgo de que tus pruebas fallen debido a que aumenta la duración de estas. Por regla general cuanto mas largos sean los tests mas frágiles y poco fiables son.\nLas implementaciones del WebDriver que son conformes al W3C también marcan el objecto navigator con la propiedad WebDriver para que los ataques de denegación de servicio (DoS) puedan ser mitigados.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/grid/when_to_use_grid/",
	"title": "Cuando usar el Grid",
	"tags": [],
	"description": "",
	"content": "Generalmente hablando, hay dos razones por las cuales podrías querer usar el Grid.\n Para ejecutar tus tests contra múltiples navegadores, múltiples versiones de navegadores y múltiples navegadores bajo diferentes sistemas operativos. Para reducir el tiempo que tarda en completarse la ejecución de tu suite de test.  El Grid se usa para acelerar la ejecución de los test usando múltiples maquinas para ejecutarlos en paralelo. Por ejemplo, si tienes una suite con 100 tests, pero configuras el Grid para soportar cuatro maquinas diferentes (ya sean maquinas virtuales o maquinas separadas físicamente) para ejecutar los tests, tu suite completará la ejecución en aproximadamente una cuarta parte del tiempo que habría tardado si se hubiesen ejecutado de manera secuencial en una sola maquina. Para suites de test grandes y suites de larga duración, como aquellas que realizan gran cantidad de validaciones de datos, puede suponer un gran ahorro de tiempo. Algunas suites de test pueden llegar tardar horas en ejecutarse. Otra razón puede ser acortar el tiempo de espera para recibir los resultados de los tests cuando los desarrolladores suben el código de su aplicación a los entornos de pruebas . Cada vez mas equipos de software practican metodologías de desarrollo software Agile en las cuales es necesario tener feedback tan rápido como sea posible en lugar de esperar durante toda la noche para que los tests finalicen su ejecución.\nEl Grid también es usado para soportar múltiples ejecuciones de test contra múltiples entornos, especialmente, contra diferentes navegadores al mismo tiempo. Por ejemplo, un Grid de maquinas virtuales puede ser configurado con cada una soportando un navegador diferente, estos navegadores pueden ser aquellos que la aplicación deba soportar. Así, la maquina uno tiene Internet Explorer 8, la maquina dos Internet Explorer 9, la maquina tres la ultima versión de Chrome y la maquina cuatro la ultima versión de Firefox. Cuando la suite de test es ejecutada, el Grid de Selenium recibe cada combinación de test-navegador y asigna la ejecución al navegador requerido.\nAdicionalmente, uno puede tener en el Grid los mismos navegadores, tipos y versiones. Por ejemplo podría tener en el Grid cuatro maquinas cada una ejecutando tres instancias de Firefox 70, permitiendo así tener una granja de servidores (en cierto sentido) de instancias de Firefox. De esta manera cuando se ejecute la suite, cada test es pasado al Grid el cual lo asignará a la siguiente instancia de Firefox disponible. De esta forma se obtendrían los resultados en los cuales doce tests se habrán estado ejecutando todos a mismo tiempo en paralelo, reduciendo así significativamente el tiempo que se requiere en completar la ejecución de la suite.\nEl Grid es muy flexible. Estos dos ejemplos pueden ser combinados para permitir múltiples instancias de cada tipo de navegador y versión. Configuraciones de este tipo permiten proveer una paralelización para completar las ejecuciones mas rápidamente y soportar múltiples tipos de navegadores y versiones simultáneamente.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Ejecutando acciones en el AUT*",
	"tags": [],
	"description": "",
	"content": " Puede especificar el texto de un elemento utilizando el método sendKeys de la siguiente manera:\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element_by_name(\u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     Algunas aplicaciones web utilizan librerías de JavaScript para agregar la funcionalidad de arrastrar y soltar. El siguiente es un ejemplo básico de arrastrar un elemento hacia otro elemento:\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element_by_id(\u0026#34;source\u0026#34;) target = driver.find_element_by_id(\u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     Haciendo clic en un elemento Puedes hacer clic en un elemento utilizando el método click:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element_by_css_selector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     *AUT: Application Under Test (Aplicación bajo prueba)\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/waits/",
	"title": "Esperas",
	"tags": [],
	"description": "",
	"content": " Generalmente se puede decir que WebDriver posee una API de bloqueo. Porque es una biblioteca fuera-de-proceso que instruye al navegador qué hacer, y debido a que la plataforma web tiene una naturaleza intrínsecamente asíncrona, WebDriver no rastrea el estado activo y en tiempo real del DOM. Esto viene con algunos desafíos que discutiremos aquí.\nPor experiencia la mayoría de las intermitencias que surgen del uso de Selenium y WebDriver están conectadas a condiciones de carrera que ocurren entre el navegador y las instrucciones del usuario. Un ejemplo podría ser que el usuario indique al navegador que navegue a una página, luego cuando intentas encontrar un elemento obtienes el error no existe tal elemento.\nConsidera el siguiente documento:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; Las instrucciones de WebDriver pueden parecer lo suficientemente inocentes:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Obtén y almacena el texto del párrafo search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     El problema aquí es que la estrategia de carga de página predeterminada utilizada en WebDriver escucha a que el document.readyState cambie a \u0026quot;complete\u0026quot; antes de retornar de la llamada a navigate. Debido a que el elemento p se agregó después de que el documento haya cargado por completo, este script de WebDriver podría ser intermitente. \u0026ldquo;Podría\u0026rdquo; ser intermitente porque no se pueden hacer garantías sobre elementos o eventos que se disparan de forma asíncrona sin esperar —o bloquear— explícitamente esos eventos.\nAfortunadamente, utilizando el conjunto normal de instrucciones disponibles en la interfaz WebElement tales como —WebElement.click y _WebElement.sendKeys_— que son garantizados para ser síncronos, esto es que las llamadas a funciones no retornaran (o el callback no se activará en los lenguajes de estilo callback) hasta que el comando se haya completado en el navegador. Las API avanzadas de interacción del usuario, Keyboard y Mouse, son excepciones ya que están explícitamente pensadas como comandos asíncronos \u0026ldquo;Haz lo que digo\u0026rdquo;.\nEsperar es hacer que la ejecución automatizada de la tarea transcurra una cierta cantidad de tiempo antes de continuar con el siguiente paso.\nPara superar el problema de las condiciones de carrera. entre el navegador y tu script de WebDriver, la mayoría de los clientes de Selenium se entregan con un paquete wait. Al emplear una espera, está utilizando lo que comúnmente se conoce como una explicit wait.\nExplicit wait Las esperas explícitas están disponibles para los clientes de lenguajes imperativos y procedimentales de Selenium. Permiten que tu código detenga la ejecución del programa, o congelar el hilo, hasta que la condición que le pases se resuelva. La condición se llama con cierta frecuencia, hasta que transcurra el tiempo de espera. Esto significa que mientras la condición retorne un valor falso, seguirá intentando y esperando.\nDado que las esperas explícitas te permiten esperar a que ocurra una condición, hacen una buena combinación para sincronizar el estado entre el navegador y su DOM, y tu script de WebDriver.\nPara remediar nuestro conjunto anterior de instrucciones con errores, podríamos esperar a que la llamada findElement espere hasta que el elemento agregado dinámicamente desde el script se haya agregado al DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Inicializa y espera hasta que se haga clic en el element(link): tiempo de espera en 10 segundos WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Imprime en pantalla el primer resultado System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Inicializa y espera hasta que se haga clic en el element(link): tiempo de espera en 10 segundos val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Imprime en pantalla el primer resultado println(firstResult.text)     Pasamos la condición como referencia de la función que wait ejecutará repetidamente hasta que su valor de retorno sea verdadero. Un valor de retorno \u0026ldquo;verdadero\u0026rdquo; es todo lo que se evalúa como booleano verdadero en el lenguaje en cuestión, como una cadena de caracteres, un número, un booleano, un objeto (incluido un WebElement), o una secuencia o lista poblada (no vacía). Eso significa que una lista vacía se evalúa como falsa. Cuando la condición es verdadera y se cancela el bloqueo de espera, el valor de retorno de la condición se convierte en el valor de retorno de la espera.\nCon este conocimiento, y debido a que la utilidad de espera ignora por defecto los errores no such element, podemos refactorizar nuestras instrucciones para hacerlas mas concisas:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     En este ejemplo, pasamos una función anónima (pero también podríamos definirlo explícitamente como lo hicimos anteriormente para que pueda reutilizarse). El primer y único argumento que se pasa a nuestra condición siempre es una referencia a nuestro objeto controlador, WebDriver (llamado d en el ejemplo). En un entorno multiproceso, debes tener cuidado operando en la referencia del controlador pasada a la condición en lugar de la referencia al controlador en el ámbito externo.\nDebido a que la espera se tragará los errores no such element que se generan cuando no se encuentra el elemento, la condición volverá a intentar hasta que se encuentre el elemento. Luego tomará el valor de retorno, un WebElement, y lo pasara nuevamente a nuestro script.\nSi la condición falla, p.ej. nunca se alcanza un valor de retorno verdadero para la condición, la espera arrojará/generará un error/excepción llamado timeout error.\nOptions La condición de espera se puede personalizar para satisfacer tus necesidades. A veces es innecesario esperar completamente el tiempo de espera predeterminado, ya que la penalización por no alcanzar una condición exitosa puede ser costosa.\nLa espera te permite pasar un argumento para anular el tiempo de espera:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     Expected conditions Porque es una ocurrencia bastante común tener que sincronizar el DOM y tus instrucciones, La mayoría de los clientes también vienen con un conjunto de condiciones esperadas predefinidas. Como podría ser obvio por el nombre, son condiciones predefinidas para operaciones frecuentes de espera.\nLas condiciones disponibles varían en las diferentes librerias enlace de los lenguajes, pero esta es una lista no exhaustiva de algunos:\n alert is present (la alerta esta presente) element exists (el elemento existe) element is visible (el elemento es visible) title contains (el titulo contiene) title is (el titulo es) element staleness (estancamiento del elemento) visible text (texto visible)  Puedes consultar la documentación de las API para las librerias de enlace de cada cliente para encontrar una lista exhaustiva de las expected conditions:\n La clase de Java org.openqa.selenium.support.ui.ExpectedConditions La clase dePython selenium.webdriver.support.expected_conditions En .NET el tipo OpenQA.Selenium.Support.UI.ExpectedConditions  Implicit wait Hay un segundo tipo de espera que es distinto de esperas explícitas llamada implicit wait. Al esperar implícitamente, WebDriver sondea el DOM por una cierta duración al intentar encontrar cualquier elemento. Esto puede ser útil cuando ciertos elementos en la página web no están disponibles de inmediato y necesitan algo de tiempo para cargarse.\nEsperar implicitamente que aparezcan elementos está deshabilitado de forma predeterminada y deberá habilitarse manualmente por sesión. Mezclar esperas explícitas y esperas implícitas causará consecuencias no deseadas, es decir, esperara el máximo de tiempo incluso si el elemento está disponible o la condición es verdadera.\nAdvertencia: No mezcles esperas implícitas y explícitas. Hacerlo puede causar tiempos de espera impredecibles. Por ejemplo, establecer una espera implícita de 10 segundos y una espera explícita de 15 segundos podría provocar que ocurra un timeout después de 20 segundos.\nUna espera implícita es decirle a WebDriver que sondee el DOM durante un cierto período de tiempo al intentar encontrar un elemento o elementos si no están disponibles de inmediato. La configuración predeterminada es 0, lo que significa deshabilitado. Una vez establecido, la espera implícita se establece por el tiempo de vida de la sesión.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element_by_id(\u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Aplica un tiempo de espera timeout por 10 segundos await driver.manage().setTimeouts( { implicit: 10000 } ); // Navega a la URL await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait La instancia de FluentWait define la cantidad máxima de tiempo para esperar por una condición, así como la frecuencia con la que verificar dicha condición.\nLos usuarios pueden configurar la espera para ignorar tipos específicos de excepciones mientras esperan, como NoSuchElementException cuando buscan un elemento en la página.\nJava Python C# Ruby JavaScript Kotlin // Esperando 30 segundos a que un elemento este presente en la página, verificando // si está presente una vez cada 5 segundos  Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Esperando 30 segundos a que un elemento este presente en la página, chequeando  // si está presente una vez cada 5 segundos  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "
},
{
	"uri": "https://selenium.dev/documentation/es/getting_started_with_webdriver/",
	"title": "Iniciando con WebDriver",
	"tags": [],
	"description": "",
	"content": " Iniciando con WebDriver Selenium permite la automatización de todos los principales navegadores del mercado mediante el uso de WebDriver. WebDriver es una API y un protocolo que define una interfaz de idioma neutral para controlar el comportamiento de los navegadores web. Cada navegador está respaldado por una implementación específica de WebDriver, llamada controlador. El controlador es el componente responsable de delegar en el navegador, y maneja la comunicación hacia y desde Selenium y el navegador.\nEsta separación es parte de un esfuerzo consciente para hacer que los proveedores de navegadores asuman la responsabilidad de la implementación para sus navegadores. Selenium utiliza estos controladores de terceros cuando es posible, pero también proporciona sus propios controladores mantenidos por el proyecto para los casos en que esto no es una realidad.\nEl framework de Selenium unifica todas estas piezas a través de una interfaz orientada al usuario que habilita que los diferentes backends de los navegadores sean utilizados de forma transparente, permitiendo la automatización cruzada entre navegadores y plataformas diferentes.\nSe pueden encontrar más detalles sobre los controladores en Idiosincrasias del controlador.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/selenium_ide/",
	"title": "Legacy Selenium IDE",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Introduction The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element. This is not only a time-saver, but also an excellent way of learning Selenium script syntax.\nThis chapter is all about the Selenium IDE and how to use it effectively.\nInstalling the IDE Using Firefox, first, download the IDE from the SeleniumHQ downloads page\nFirefox will protect you from installing addons from unfamiliar locations, so you will need to click ‘Allow’ to proceed with the installation, as shown in the following screenshot.\nWhen downloading from Firefox, you’ll be presented with the following window.\nSelect Install Now. The Firefox Add-ons window pops up, first showing a progress bar, and when the download is complete, displays the following.\nRestart Firefox. After Firefox reboots you will find the Selenium-IDE listed under the Firefox Tools menu.\nOpening the IDE To run the Selenium-IDE, simply select it from the Firefox Tools menu. It opens as follows with an empty script-editing window and a menu for loading, or creating new test cases.\nIDE Features Menu Bar The File menu has options for Test Case and Test Suite (suite of Test Cases). Using these you can add a new Test Case, open a Test Case, save a Test Case, export Test Case in a language of your choice. You can also open the recent Test Case. All these options are also available for Test Suite.\nThe Edit menu allows copy, paste, delete, undo, and select all operations for editing the commands in your test case. The Options menu allows the changing of settings. You can set the timeout value for certain commands, add user-defined user extensions to the base set of Selenium commands, and specify the format (language) used when saving your test cases. The Help menu is the standard Firefox Help menu; only one item on this menu–UI-Element Documentation–pertains to Selenium-IDE.\nToolbar The toolbar contains buttons for controlling the execution of your test cases, including a step feature for debugging your test cases. The right-most button, the one with the red-dot, is the record button.\nSpeed Control: controls how fast your test case runs.\nRun All: Runs the entire test suite when a test suite with multiple test cases is loaded.\nRun: Runs the currently selected test. When only a single test is loaded this button and the Run All button have the same effect.\nPause/Resume: Allows stopping and re-starting of a running test case.\nStep: Allows you to “step” through a test case by running it one command at a time. Use for debugging test cases.\nTestRunner Mode: Allows you to run the test case in a browser loaded with the Selenium-Core TestRunner. The TestRunner is not commonly used now and is likely to be deprecated. This button is for evaluating test cases for backwards compatibility with the TestRunner. Most users will probably not need this button.\nApply Rollup Rules: This advanced feature allows repetitive sequences of Selenium commands to be grouped into a single action. Detailed documentation on rollup rules can be found in the UI-Element Documentation on the Help menu.\nTest Case Pane Your script is displayed in the test case pane. It has two tabs, one for displaying the command and their parameters in a readable “table” format.\nThe other tab - Source displays the test case in the native format in which the file will be stored. By default, this is HTML although it can be changed to a programming language such as Java or C#, or a scripting language like Python. See the Options menu for details. The Source view also allows one to edit the test case in its raw form, including copy, cut and paste operations.\nThe Command, Target, and Value entry fields display the currently selected command along with its parameters. These are entry fields where you can modify the currently selected command. The first parameter specified for a command in the Reference tab of the bottom pane always goes in the Target field. If a second parameter is specified by the Reference tab, it always goes in the Value field.\nIf you start typing in the Command field, a drop-down list will be populated based on the first characters you type; you can then select your desired command from the drop-down.\nLog/Reference/UI-Element/Rollup Pane The bottom pane is used for four different functions–Log, Reference, UI-Element, and Rollup–depending on which tab is selected.\nLog When you run your test case, error messages and information messages showing the progress are displayed in this pane automatically, even if you do not first select the Log tab. These messages are often useful for test case debugging. Notice the Clear button for clearing the Log. Also notice the Info button is a drop-down allowing selection of different levels of information to log.\nReference The Reference tab is the default selection whenever you are entering or modifying Selenese commands and parameters in Table mode. In Table mode, the Reference pane will display documentation on the current command. When entering or modifying commands, whether from Table or Source mode, it is critically important to ensure that the parameters specified in the Target and Value fields match those specified in the parameter list in the Reference pane. The number of parameters provided must match the number specified, the order of parameters provided must match the order specified, and the type of parameters provided must match the type specified. If there is a mismatch in any of these three areas, the command will not run correctly.\nWhile the Reference tab is invaluable as a quick reference, it is still often necessary to consult the Selenium Reference document.\nUI-Element and Rollup Detailed information on these two panes (which cover advanced features) can be found in the UI-Element Documentation on the Help menu of Selenium-IDE.\nBuilding Test Cases There are three primary methods for developing test cases. Frequently, a test developer will require all three techniques.\nRecording Many first-time users begin by recording a test case from their interactions with a website. When Selenium-IDE is first opened, the record button is ON by default. If you do not want Selenium-IDE to begin recording automatically you can turn this off by going under Options \u0026gt; Options… and deselecting “Start recording immediately on open.”\nDuring recording, Selenium-IDE will automatically insert commands into your test case based on your actions. Typically, this will include:\n clicking a link - click or clickAndWait commands entering values - type command selecting options from a drop-down listbox - select command clicking checkboxes or radio buttons - click command  Here are some “gotchas” to be aware of:\n The type command may require clicking on some other area of the web page for it to record. Following a link usually records a click command. You will often need to change this to clickAndWait to ensure your test case pauses until the new page is completely loaded. Otherwise, your test case will continue running commands before the page has loaded all its UI elements. This will cause unexpected test case failures.  Adding Verifications and Asserts With the Context Menu Your test cases will also need to check the properties of a web-page. This requires assert and verify commands. We won’t describe the specifics of these commands here; that is in the chapter on Selenium Commands – “Selenese”. Here we’ll simply describe how to add them to your test case.\nWith Selenium-IDE recording, go to the browser displaying your test application and right click anywhere on the page. You will see a context menu showing verify and/or assert commands.\nThe first time you use Selenium, there may only be one Selenium command listed. As you use the IDE however, you will find additional commands will quickly be added to this menu. Selenium-IDE will attempt to predict what command, along with the parameters, you will need for a selected UI element on the current web-page.\nLet’s see how this works. Open a web-page of your choosing and select a block of text on the page. A paragraph or a heading will work fine. Now, right-click the selected text. The context menu should give you a verifyTextPresent command and the suggested parameter should be the text itself.\nAlso, notice the Show All Available Commands menu option. This shows many, many more commands, again, along with suggested parameters, for testing your currently selected UI element.\nTry a few more UI elements. Try right-clicking an image, or a user control like a button or a checkbox. You may need to use Show All Available Commands to see options other than verifyTextPresent. Once you select these other options, the more commonly used ones will show up on the primary context menu. For example, selecting verifyElementPresent for an image should later cause that command to be available on the primary context menu the next time you select an image and right-click.\nAgain, these commands will be explained in detail in the chapter on Selenium commands. For now though, feel free to use the IDE to record and select commands into a test case and then run it. You can learn a lot about the Selenium commands simply by experimenting with the IDE.\nEditing Insert Command Table View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click on the line where you want to insert a new command. Right-click and select Insert Command; the IDE will add a blank line just ahead of the line you selected. Now use the command editing text fields to enter your new command and its parameters.\nSource View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click between the commands where you want to insert a new command, and enter the HTML tags needed to create a 3-column row containing the Command, first parameter (if one is required by the Command), and second parameter (again, if one is required to locate an element) and third parameter(again, if one is required to have a value). Example:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Insert Comment Comments may be added to make your test case more readable. These comments are ignored when the test case is run.\nComments may also be used to add vertical white space (one or more blank lines) in your tests; just create empty comments. An empty command will cause an error during execution; an empty comment won’t.\nTable View Select the line in your test case where you want to insert the comment. Right-click and select Insert Comment. Now use the Command field to enter the comment. Your comment will appear in purple text.\nSource View Select the point in your test case where you want to insert the comment. Add an HTML-style comment, i.e., \u0026lt;!-- your comment here --\u0026gt;.\nEdit a Command or Comment Table View Simply select the line to be changed and edit it using the Command, Target, and Value fields.\nSource View Since Source view provides the equivalent of a WYSIWYG (What You See is What You Get) editor, simply modify which line you wish–command, parameter, or comment.\nOpening and Saving a Test Case Like most programs, there are Save and Open commands under the File menu. However, Selenium distinguishes between test cases and test suites. To save your Selenium-IDE tests for later use you can either save the individual test cases, or save the test suite. If the test cases of your test suite have not been saved, you’ll be prompted to save them before saving the test suite.\nWhen you open an existing test case or suite, Selenium-IDE displays its Selenium commands in the Test Case Pane.\nRunning Test Cases The IDE allows many options for running your test case. You can run a test case all at once, stop and start it, run it one line at a time, run a single command you are currently developing, and you can do a batch run of an entire test suite. Execution of test cases is very flexible in the IDE.\nRun a Test Case\nClick the Run button to run the currently displayed test case.\nRun a Test Suite\nClick the Run All button to run all the test cases in the currently loaded test suite.\nStop and Start\nThe Pause button can be used to stop the test case while it is running. The icon of this button then changes to indicate the Resume button. To continue click Resume.\nStop in the Middle\nYou can set a breakpoint in the test case to cause it to stop on a particular command. This is useful for debugging your test case. To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint.\nStart from the Middle\nYou can tell the IDE to begin running from a specific command in the middle of the test case. This also is used for debugging. To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point.\nRun Any Single Command\nDouble-click any single command to run it by itself. This is useful when writing a single command. It lets you immediately test a command you are constructing, when you are not sure if it is correct. You can double-click it to see if it runs correctly. This is also available from the context menu.\nUsing Base URL to Run Test Cases in Different Domains The Base URL field at the top of the Selenium-IDE window is very useful for allowing test cases to be run across different domains. Suppose that a site named http://news.portal.com had an in-house beta site named http://beta.news.portal.com. Any test cases for these sites that begin with an open statement should specify a relative URL as the argument to open rather than an absolute URL (one starting with a protocol such as http: or https:). Selenium-IDE will then create an absolute URL by appending the open command’s argument onto the end of the value of Base URL. For example, the test case below would be run against http://news.portal.com/about.html:\nThis same test case with a modified Base URL setting would be run against http://beta.news.portal.com/about.html:\nSelenium Commands – “Selenese” Selenium commands, often called selenese, are the set of commands that run your tests. A sequence of these commands is a test script. Here we explain those commands in detail, and we present the many choices you have in testing your web application when using Selenium.\nSelenium provides a rich set of commands for fully testing your web-app in virtually any way you can imagine. The command set is often called selenese. These commands essentially create a testing language.\nIn selenese, one can test the existence of UI elements based on their HTML tags, test for specific content, test for broken links, input fields, selection list options, submitting forms, and table data among other things. In addition Selenium commands support testing of window size, mouse position, alerts, Ajax functionality, pop up windows, event handling, and many other web-application features. The Command Reference lists all the available commands.\nA command tells Selenium what to do. Selenium commands come in three “flavors”: Actions, Accessors, and Assertions.\n Actions are commands that generally manipulate the state of the application. They do things like “click this link” and “select that option”. If an Action fails, or has an error, the execution of the current test is stopped.\nMany Actions can be called with the “AndWait” suffix, e.g. “clickAndWait”. This suffix tells Selenium that the action will cause the browser to make a call to the server, and that Selenium should wait for a new page to load.\n Accessors examine the state of the application and store the results in variables, e.g. “storeTitle”. They are also used to automatically generate Assertions.\n Assertions are like Accessors, but they verify that the state of the application conforms to what is expected. Examples include “make sure the page title is X” and “verify that this checkbox is checked”.\n  All Selenium Assertions can be used in 3 modes: “assert”, “verify”, and ” waitFor”. For example, you can “assertText”, “verifyText” and “waitForText”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure. This allows a single “assert” to ensure that the application is on the correct page, followed by a bunch of “verify” assertions to test form field values, labels, etc.\n“waitFor” commands wait for some condition to become true (which can be useful for testing Ajax applications). They will succeed immediately if the condition is already true. However, they will fail and halt the test if the condition does not become true within the current timeout setting (see the setTimeout action below).\nScript Syntax Selenium commands are simple, they consist of the command and two parameters. For example:\n          verifyText //div//a[2] Login    The parameters are not always required; it depends on the command. In some cases both are required, in others one parameter is required, and in still others the command may take no parameters at all. Here are a couple more examples:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    The command reference describes the parameter requirements for each command.\nParameters vary, however they are typically:\n a locator for identifying a UI element within a page. a text pattern for verifying or asserting expected page content a text pattern or a Selenium variable for entering text in an input field or for selecting an option from an option list.  Locators, text patterns, Selenium variables, and the commands themselves are described in considerable detail in the section on Selenium Commands.\nSelenium scripts that will be run from Selenium-IDE will be stored in an HTML text file format. This consists of an HTML table with three columns. The first column identifies the Selenium command, the second is a target, and the final column contains a value. The second and third columns may not require values depending on the chosen Selenium command, but they should be present. Each table row represents a new Selenium command. Here is an example of a test that opens a page, asserts the page title and then verifies some content on the page:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Rendered as a table in a browser this would look like the following:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language. With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.\nTest Suites A test suite is a collection of tests. Often one will run all the tests in a test suite as one continuous batch-job.\nWhen using Selenium-IDE, test suites also can be defined using a simple HTML file. The syntax again is simple. An HTML table defines a list of tests where each row defines the filesystem path to each test. An example tells it all.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; A file similar to this would allow running the tests all at once, one after another, from the Selenium-IDE.\nTest suites can also be maintained when using Selenium-RC. This is done via programming and can be done a number of ways. Commonly Junit is used to maintain a test suite if one is using Selenium-RC with Java. Additionally, if C# is the chosen language, Nunit could be employed. If using an interpreted language like Python with Selenium-RC then some simple programming would be involved in setting up a test suite. Since the whole reason for using Selenium-RC is to make use of programming logic for your testing this usually isn’t a problem.\nCommonly Used Selenium Commands To conclude our introduction of Selenium, we’ll show you a few typical Selenium commands. These are probably the most commonly used commands for building tests.\nopen\nopens a page using a URL.\nclick/clickAndWait\nperforms a click operation, and optionally waits for a new page to load.\nverifyTitle/assertTitle\nverifies an expected page title.\nverifyTextPresent\nverifies expected text is somewhere on the page.\nverifyElementPresent\nverifies an expected UI element, as defined by its HTML tag, is present on the page.\nverifyText\nverifies expected text and its corresponding HTML tag are present on the page.\nverifyTable\nverifies a table’s expected contents.\nwaitForPageToLoad\npauses execution until an expected new page loads. Called automatically when clickAndWait is used.\nwaitForElementPresent\npauses execution until an expected UI element, as defined by its HTML tag, is present on the page.\nVerifying Page Elements Verifying UI elements on a web page is probably the most common feature of your automated tests. Selenese allows multiple ways of checking for UI elements. It is important that you understand these different methods because these methods define what you are actually testing.\nFor example, will you test that…\n an element is present somewhere on the page? specific text is somewhere on the page? specific text is at a specific location on the page?  For example, if you are testing a text heading, the text and its position at the top of the page are probably relevant for your test. If, however, you are testing for the existence of an image on the home page, and the web designers frequently change the specific image file along with its position on the page, then you only want to test that an image (as opposed to the specific image file) exists somewhere on the page.\nAssertion or Verification? Choosing between “assert” and “verify” comes down to convenience and management of failures. There’s very little point checking that the first paragraph on the page is the correct one if your test has already failed when checking that the browser is displaying the expected page. If you’re not on the correct page, you’ll probably want to abort your test case so that you can investigate the cause and fix the issue(s) promptly. On the other hand, you may want to check many attributes of a page without aborting the test case on the first failure as this will allow you to review all failures on the page and take the appropriate action. Effectively an “assert” will fail the test and abort the current test case, whereas a “verify” will fail the test and continue to run the test case.\nThe best use of this feature is to logically group your test commands, and start each group with an “assert” followed by one or more “verify” test commands. An example follows:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    The above example first opens a page and then “asserts” that the correct page is loaded by comparing the title with the expected value. Only if this passes will the following command run and “verify” that the text is present in the expected location. The test case then “asserts” the first column in the second row of the first table contains the expected value, and only if this passed will the remaining cells in that row be “verified”.\nverifyTextPresent The command verifyTextPresent is used to verify specific text exists somewhere on the page. It takes a single argument–the text pattern to be verified. For example:\n   Command Target Value     verifyTextPresent Marketing Analysis     This would cause Selenium to search for, and verify, that the text string “Marketing Analysis” appears somewhere on the page currently being tested. Use verifyTextPresent when you are interested in only the text itself being present on the page. Do not use this when you also need to test where the text occurs on the page.\nverifyElementPresent Use this command when you must test for the presence of a specific UI element, rather than its content. This verification does not check the text, only the HTML tag. One common use is to check for the presence of an image.\n   Command Target Value     verifyElementPresent //div/p/img     This command verifies that an image, specified by the existence of an  HTML tag, is present on the page, and that it follows a  tag and a  tag. The first (and only) parameter is a locator for telling the Selenese command how to find the element. Locators are explained in the next section.\nverifyElementPresent can be used to check the existence of any HTML tag within the page. You can check the existence of links, paragraphs, divisions , etc. Here are a few more examples.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     These examples illustrate the variety of ways a UI element may be tested. Again, locators are explained in the next section.\nverifyText Use verifyText when both the text and its UI element must be tested. verifyText must use a locator. If you choose an XPath or DOM locator, you can verify that specific text appears at a specific location on the page relative to other UI components on the page.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Locating Elements For many Selenium commands, a target is required. This target identifies an element in the content of the web application, and consists of the location strategy followed by the location in the format locatorType=location. The locator type can be omitted in many cases. The various locator types are explained below with examples for each.\nLocating by Identifier This is probably the most common method of locating elements and is the catch-all default when no recognized locator type is used. With this strategy, the first element with the id attribute value matching the location will be used. If no element has a matching id attribute, then the first element with a name attribute matching the location will be used.\nFor instance, your page source could have id and name attributes as follows:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; The following locator strategies would return the elements from the HTML snippet above indicated by line number:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Since the identifier type of locator is the default, the identifier= in the first three examples above is not necessary.\nLocating by Id This type of locator is more limited than the identifier locator type, but also more explicit. Use this when you know an element\u0026rsquo;s id attribute.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Locating by Name The name locator type will locate the first element with a matching name attribute. If multiple elements have the same value for a name attribute, then you can use filters to further refine your location strategy. The default filter type is value (matching the value attribute).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Note: Unlike some types of XPath and DOM locators, the three types of locators above allow Selenium to test a UI element independent of its location on the page. So if the page structure and organization is altered, the test will still pass. You may or may not want to also test whether the page structure changes. In the case where web designers frequently alter the page, but its functionality must be regression tested, testing via id and name attributes, or really via any HTML property, becomes very important.\nLocating by XPath XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.\nOne of the main reasons for using XPath is when you don\u0026rsquo;t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.\nAbsolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.\nSince only xpath locators start with \u0026ldquo;//\u0026rdquo;, it is not necessary to include the xpath= label when specifying an XPath locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Absolute path (would break if the HTML was changed only slightly) //form[1] (3) - First form element in the HTML xpath=//form[@id='loginForm'] (3) - The form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - First form element with an input child element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - First input element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - First input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - Input with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;continue\u0026rsquo; and attribute named \u0026lsquo;type\u0026rsquo; and the value \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Fourth input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and value \u0026lsquo;loginForm\u0026rsquo;  These examples cover some basics, but in order to learn more, the following references are recommended:\n W3Schools XPath Tutorial W3C XPath Recommendation  There are also a couple of very useful Firefox Add-ons that can assist in discovering the XPath of an element:\n XPath Checker XPath and can be used to test XPath results. [Firebug](https://addons.mozilla.org/en-US/firefox/addon/1843 - XPath suggestions are just one of the many powerful features of this very useful add-on.  Locating Hyperlinks by Link Text This is a simple method of locating a hyperlink in your web page by using the text of the link. If two links with the same text are present, then the first match will be used.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Locating by DOM The Document Object Model represents an HTML document and can be accessed using JavaScript. This location strategy takes JavaScript that evaluates to an element on the page, which can be simply the element\u0026rsquo;s location using the hierarchical dotted notation.\nSince only dom locators start with \u0026ldquo;document\u0026rdquo;, it is not necessary to include the dom= label when specifying a DOM locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  You can use Selenium itself as well as other sites and extensions to explore the DOM of your web application. A good reference exists on W3Schools.\nLocating by CSS CSS (Cascading Style Sheets) is a language for describing the rendering of HTML and XML documents. CSS uses Selectors for binding style properties to elements in the document. These Selectors can be used by Selenium as another locating strategy.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  For more information about CSS Selectors, the best place to go is the W3C publication. You\u0026rsquo;ll find additional references there.\nImplicit Locators You can choose to omit the locator type in the following situations:\n Locators without an explicitly defined locator strategy will default to using the identifier locator strategy. See Locating by Identifier_.\n Locators starting with \u0026ldquo;//\u0026rdquo; will use the XPath locator strategy. See Locating by XPath_.\n Locators starting with \u0026ldquo;document\u0026rdquo; will use the DOM locator strategy. See Locating by DOM_\n  Matching Text Patterns Like locators, patterns are a type of parameter frequently required by Selenese commands. Examples of commands which require patterns are verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, and verifyPrompt. And as has been mentioned above, link locators can utilize a pattern. Patterns allow you to describe, via the use of special characters, what text is expected rather than having to specify that text exactly.\nThere are three types of patterns: globbing, regular expressions, and exact.\nGlobbing Patterns Most people are familiar with globbing as it is utilized in filename expansion at a DOS or Unix/Linux command line such as ls *.c. In this case, globbing is used to display all the files ending with a .c extension that exist in the current directory. Globbing is fairly limited.\nOnly two special characters are supported in the Selenium implementation:\n* which translates to \u0026ldquo;match anything,\u0026rdquo; i.e., nothing, a single character, or many characters.\n[ ] (character class) which translates to \u0026ldquo;match any single character found inside the square brackets.\u0026rdquo; A dash (hyphen) can be used as a shorthand to specify a range of characters (which are contiguous in the ASCII character set). A few examples will make the functionality of a character class clear:\n[aeiou] matches any lowercase vowel\n[0-9] matches any digit\n[a-zA-Z0-9] matches any alphanumeric character\nIn most other contexts, globbing includes a third special character, the ?. However, Selenium globbing patterns only support the asterisk and character class.\nTo specify a globbing pattern parameter for a Selenese command, you can prefix the pattern with a glob: label. However, because globbing patterns are the default, you can also omit the label and specify just the pattern itself.\nBelow is an example of two commands that use globbing patterns. The actual link text on the page being tested was \u0026ldquo;Film/Television Department\u0026rdquo;; by using a pattern rather than the exact text, the click command will work even if the link text is changed to \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; or \u0026ldquo;Film and Television Department\u0026rdquo;. The glob pattern\u0026rsquo;s asterisk will match \u0026ldquo;anything or nothing\u0026rdquo; between the word \u0026ldquo;Film\u0026rdquo; and the word \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     The actual title of the page reached by clicking on the link was \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. By using a pattern rather than the exact text, the verifyTitle will pass as long as the two words \u0026ldquo;Film\u0026rdquo; and \u0026ldquo;Television\u0026rdquo; appear (in that order) anywhere in the page\u0026rsquo;s title. For example, if the page\u0026rsquo;s owner should shorten the title to just \u0026ldquo;Film \u0026amp; Television Department,\u0026rdquo; the test would still pass. Using a pattern for both a link and a simple test that the link worked (such as the verifyTitle above does) can greatly reduce the maintenance for such test cases.\nRegular Expression Patterns Regular expression patterns are the most powerful of the three types of patterns that Selenese supports. Regular expressions are also supported by most high-level programming languages, many text editors, and a host of tools, including the Linux/Unix command-line utilities grep, sed, and awk. In Selenese, regular expression patterns allow a user to perform many tasks that would be very difficult otherwise. For example, suppose your test needed to ensure that a particular table cell contained nothing but a number. regexp: [0-9]+ is a simple pattern that will match a decimal number of any length.\nWhereas Selenese globbing patterns support only the * and [ ] (character class) features, Selenese regular expression patterns offer the same wide array of special characters that exist in JavaScript. Below are a subset of those special characters:\n   PATTERN MATCH     . any single character   [ ] character class: any single character that appears inside the brackets   * quantifier: 0 or more of the preceding character (or group)   + quantifier: 1 or more of the preceding character (or group)   ? quantifier: 0 or 1 of the preceding character (or group)   {1,5} quantifier: 1 through 5 of the preceding character (or group)   | alternation: the character/group on the left or the character/group on the right   ( ) grouping: often used with alternation and/or quantifier    Regular expression patterns in Selenese need to be prefixed with either regexp: or regexpi:. The former is case-sensitive; the latter is case-insensitive.\nA few examples will help clarify how regular expression patterns can be used with Selenese commands. The first one uses what is probably the most commonly used regular expression pattern\u0026ndash;.* (\u0026ldquo;dot star\u0026rdquo;). This two-character sequence can be translated as \u0026ldquo;0 or more occurrences of any character\u0026rdquo; or more simply, \u0026ldquo;anything or nothing.\u0026rdquo; It is the equivalent of the one-character globbing pattern * (a single asterisk).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     The example above is functionally equivalent to the earlier example that used globbing patterns for this same test. The only differences are the prefix (regexp: instead of glob:) and the \u0026ldquo;anything or nothing\u0026rdquo; pattern (.* instead of just *).\nThe more complex example below tests that the Yahoo! Weather page for Anchorage, Alaska contains info on the sunrise time:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Let\u0026rsquo;s examine the regular expression above one part at a time:\n         Sunrise: * The string Sunrise: followed by 0 or more spaces   [0-9]{1,2} 1 or 2 digits (for the hour of the day)   : The character : (no special characters involved)   [0-9]{2} 2 digits (for the minutes) followed by a space   [ap]m \u0026ldquo;a\u0026rdquo; or \u0026ldquo;p\u0026rdquo; followed by \u0026ldquo;m\u0026rdquo; (am or pm)    Exact Patterns The exact type of Selenium pattern is of marginal usefulness. It uses no special characters at all. So, if you needed to look for an actual asterisk character (which is special for both globbing and regular expression patterns), the exact pattern would be one way to do that. For example, if you wanted to select an item labeled \u0026ldquo;Real *\u0026rdquo; from a dropdown, the following code might work or it might not. The asterisk in the glob:Real * pattern will match anything or nothing. So, if there was an earlier select option labeled \u0026ldquo;Real Numbers,\u0026rdquo; it would be the option selected rather than the \u0026ldquo;Real *\u0026rdquo; option.\n   Command Target Value     select //select glob:Real *    In order to ensure that the \u0026ldquo;Real *\u0026rdquo; item would be selected, the exact: prefix could be used to create an exact pattern as shown below:\n   Command Target Value     select //select exact:Real *    But the same effect could be achieved via escaping the asterisk in a regular expression pattern:\n   Command Target Value     select //select regexp:Real \\*    It\u0026rsquo;s rather unlikely that most testers will ever need to look for an asterisk or a set of square brackets with characters inside them (the character class for globbing patterns). Thus, globbing patterns and regular expression patterns are sufficient for the vast majority of us.\nThe \u0026ldquo;AndWait\u0026rdquo; Commands The difference between a command and its AndWait alternative is that the regular command (e.g. click) will do the action and continue with the following command as fast as it can, while the AndWait alternative (e.g. clickAndWait) tells Selenium to wait for the page to load after the action has been done.\nThe AndWait alternative is always used when the action causes the browser to navigate to another page or reload the present one.\nBe aware, if you use an AndWait command for an action that does not trigger a navigation/refresh, your test will fail. This happens because Selenium will reach the AndWait\u0026rsquo;s timeout without seeing any navigation or refresh being made, causing Selenium to raise a timeout exception.\nThe waitFor Commands in AJAX applications In AJAX driven web applications, data is retrieved from server without refreshing the page. Using andWait commands will not work as the page is not actually refreshed. Pausing the test execution for a certain period of time is also not a good approach as web element might appear later or earlier than the stipulated period depending on the system\u0026rsquo;s responsiveness, load or other uncontrolled factors of the moment, leading to test failures. The best approach would be to wait for the needed element in a dynamic period and then continue the execution as soon as the element is found.\nThis is done using waitFor commands, as waitForElementPresent or waitForVisible, which wait dynamically, checking for the desired condition every second and continuing to the next command in the script as soon as the condition is met.\nSequence of Evaluation and Flow Control When a script runs, it simply runs in sequence, one command after another.\nSelenese, by itself, does not support condition statements (if-else, etc.) or iteration (for, while, etc.). Many useful tests can be conducted without flow control. However, for a functional test of dynamic content, possibly involving multiple pages, programming logic is often needed.\nWhen flow control is needed, there are three options:\na) Run the script using Selenium-RC and a client library such as Java or PHP to utilize the programming language\u0026rsquo;s flow control features. b) Run a small JavaScript snippet from within the script using the storeEval command. c) Install the goto_sel_ide.js extension.\nMost testers will export the test script into a programming language file that uses the Selenium-RC API (see the Selenium-IDE chapter). However, some organizations prefer to run their scripts from Selenium-IDE whenever possible (for instance, when they have many junior-level people running tests for them, or when programming skills are lacking). If this is your case, consider a JavaScript snippet or the goto_sel_ide.js extension.\nStore Commands and Selenium Variables You can use Selenium variables to store constants at the beginning of a script. Also, when combined with a data-driven test design (discussed in a later section), Selenium variables can be used to store values passed to your test program from the command-line, from another program, or from a file.\nThe plain store command is the most basic of the many store commands and can be used to simply store a constant value in a Selenium variable. It takes two parameters, the text value to be stored and a Selenium variable. Use the standard variable naming conventions of only alphanumeric characters when choosing a name for your variable.\n   Command Target Value     store paul@mysite.org     Later in your script, you\u0026rsquo;ll want to use the stored value of your variable. To access the value of a variable, enclose the variable in curly brackets ({}) and precede it with a dollar sign like this.\n   Command Target Value     verifyText //div/p \\${userName}    A common use of variables is for storing input for an input field.\n   Command Target Value     type id=login \\${userName}    Selenium variables can be used in either the first or second parameter and are interpreted by Selenium prior to any other operations performed by the command. A Selenium variable may also be used within a locator expression.\nAn equivalent store command exists for each verify and assert command. Here are a couple more commonly used store commands.\nstoreElementPresent This corresponds to verifyElementPresent. It simply stores a boolean value\u0026ndash;\u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;\u0026ndash;depending on whether the UI element is found.\nstoreText StoreText corresponds to verifyText. It uses a locator to identify specific page text. The text, if found, is stored in the variable. StoreText can be used to extract text from the page being tested.\nstoreEval This command takes a script as its first parameter. Embedding JavaScript within Selenese is covered in the next section. StoreEval allows the test to store the result of running the script in a variable.\nJavaScript and Selenese Parameters JavaScript can be used with two types of Selenese parameters: script and non-script (usually expressions). In most cases, you\u0026rsquo;ll want to access and/or manipulate a test case variable inside the JavaScript snippet used as a Selenese parameter. All variables created in your test case are stored in a JavaScript associative array. An associative array has string indexes rather than sequential numeric indexes. The associative array containing your test case\u0026rsquo;s variables is named storedVars. Whenever you wish to access or manipulate a variable within a JavaScript snippet, you must refer to it as storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nJavaScript Usage with Script Parameters Several Selenese commands specify a script parameter including assertEval, verifyEval, storeEval, and waitForEval. These parameters require no special syntax. A Selenium-IDE user would simply place a snippet of JavaScript code into the appropriate field, normally the Target field (because a script parameter is normally the first or only parameter).\nThe example below illustrates how a JavaScript snippet can be used to perform a simple numerical calculation:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    This next example illustrates how a JavaScript snippet can include calls to methods, in this case the JavaScript String object\u0026rsquo;s toUpperCase method and toLowerCase method.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    JavaScript Usage with Non-Script Parameters JavaScript can also be used to help generate values for parameters, even when the parameter is not specified to be of type script.\nHowever, in this case, special syntax is required\u0026ndash;the entire parameter value must be prefixed by javascript{ with a trailing }, which encloses the JavaScript snippet, as in javascript{*yourCodeHere*}. Below is an example in which the type command\u0026rsquo;s second parameter value is generated via JavaScript code using this special syntax:\n   Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - The Selenese Print Command Selenese has a simple command that allows you to print text to your test\u0026rsquo;s output. This is useful for providing informational progress notes in your test which display on the console as your test is running. These notes also can be used to provide context within your test result reports, which can be useful for finding where a defect exists on a page in the event your test finds a problem. Finally, echo statements can be used to print the contents of Selenium variables.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alerts, Popups, and Multiple Windows Suppose that you are testing a page that looks like this.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The user must respond to alert/confirm boxes, as well as moving focus to newly opened popup windows. Fortunately, Selenium can cover JavaScript pop-ups.\nBut before we begin covering alerts/confirms/prompts in individual detail, it is helpful to understand the commonality between them. Alerts, confirmation boxes and prompts all have variations of the following\n   Command Description     assertFoo(pattern) throws error if pattern doesn’t match the text of the pop-up   assertFooPresent throws error if pop-up is not available   assertFooNotPresent throws error if any pop-up is present   storeFoo(variable) stores the text of the pop-up in a variable   storeFooPresent(variable) stores the text of the pop-up in a variable and returns true or false    When running under Selenium, JavaScript pop-ups will not appear. This is because the function calls are actually being overridden at runtime by Selenium\u0026rsquo;s own JavaScript. However, just because you cannot see the pop-up doesn\u0026rsquo;t mean you don\u0026rsquo;t have to deal with it. To handle a pop-up, you must call its assertFoo(pattern) function. If you fail to assert the presence of a pop-up your next command will be blocked and you will get an error similar to the following [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlerts Let\u0026rsquo;s start with alerts because they are the simplest pop-up to handle. To begin, open the HTML sample above in a browser and click on the \u0026ldquo;Show alert\u0026rdquo; button. You\u0026rsquo;ll notice that after you close the alert the text \u0026ldquo;Alert is gone.\u0026rdquo; is displayed on the page. Now run through the same steps with Selenium IDE recording, and verify the text is added after you close the alert. Your test will look something like this:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     You may be thinking \u0026ldquo;That\u0026rsquo;s odd, I never tried to assert that alert.\u0026rdquo; But this is Selenium-IDE handling and closing the alert for you. If you remove that step and replay the test you will get the following error [error] Error: There was an unexpected Alert! [I'm blocking!]. You must include an assertion of the alert to acknowledge its presence.\nIf you just want to assert that an alert is present but either don\u0026rsquo;t know or don\u0026rsquo;t care what text it contains, you can use assertAlertPresent. This will return true or false, with false halting the test.\nConfirmations Confirmations behave in much the same way as alerts, with assertConfirmation and assertConfirmationPresent offering the same characteristics as their alert counterparts. However, by default Selenium will select OK when a confirmation pops up. Try recording clicking on the \u0026ldquo;Show confirm box\u0026rdquo; button in the sample page, but click on the \u0026ldquo;Cancel\u0026rdquo; button in the popup, then assert the output text. Your test may look something like this:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     The chooseCancelOnNextConfirmation function tells Selenium that all following confirmation should return false. It can be reset by calling chooseOkOnNextConfirmation.\nYou may notice that you cannot replay this test, because Selenium complains that there is an unhandled confirmation. This is because the order of events Selenium-IDE records causes the click and chooseCancelOnNextConfirmation to be put in the wrong order (it makes sense if you think about it, Selenium can\u0026rsquo;t know that you\u0026rsquo;re cancelling before you open a confirmation) Simply switch these two commands and your test will run fine.\nPrompts Prompts behave in much the same way as alerts, with assertPrompt and assertPromptPresent offering the same characteristics as their alert counterparts. By default, Selenium will wait for you to input data when the prompt pops up. Try recording clicking on the \u0026ldquo;Show prompt\u0026rdquo; button in the sample page and enter \u0026ldquo;Selenium\u0026rdquo; into the prompt. Your test may look something like this:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     If you choose cancel on the prompt, you may notice that answerOnNextPrompt will simply show a target of blank. Selenium treats cancel and a blank entry on the prompt basically as the same thing.\nDebugging Debugging means finding and fixing errors in your test case. This is a normal part of test case development.\nWe won\u0026rsquo;t teach debugging here as most new users to Selenium will already have some basic experience with debugging. If this is new to you, we recommend you ask one of the developers in your organization.\nBreakpoints and Startpoints The Sel-IDE supports the setting of breakpoints and the ability to start and stop the running of a test case, from any point within the test case. That is, one can run up to a specific command in the middle of the test case and inspect how the test case behaves at that point. To do this, set a breakpoint on the command just before the one to be examined.\nTo set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint. Then click the Run button to run your test case from the beginning up to the breakpoint.\nIt is also sometimes useful to run a test case from somewhere in the middle to the end of the test case or up to a breakpoint that follows the starting point.\nFor example, suppose your test case first logs into the website and then performs a series of tests and you are trying to debug one of those tests.\nHowever, you only need to login once, but you need to keep rerunning your tests as you are developing them. You can login once, then run your test case from a startpoint placed after the login portion of your test case. That will prevent you from having to manually logout each time you rerun your test case.\nTo set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point. Then click the Run button to execute the test case beginning at that startpoint.\nStepping Through a Testcase To execute a test case one command at a time (\u0026ldquo;step through\u0026rdquo; it), follow these steps:\n Start the test case running with the Run button from the toolbar.\n Immediately pause the executing test case with the Pause button.\n Repeatedly select the Step button.\n  Find Button The Find button is used to see which UI element on the currently displayed webpage (in the browser) is used in the currently selected Selenium command.\nThis is useful when building a locator for a command\u0026rsquo;s first parameter (see the section on :ref:locators \u0026lt;locators-section\u0026gt; in the Selenium Commands chapter). It can be used with any command that identifies a UI element on a webpage, i.e. click, clickAndWait, type, and certain assert and verify commands, among others.\nFrom Table view, select any command that has a locator parameter. Click the Find button.\nNow look on the webpage: There should be a bright green rectangle enclosing the element specified by the locator parameter.\nPage Source for Debugging Often, when debugging a test case, you simply must look at the page source (the HTML for the webpage you\u0026rsquo;re trying to test) to determine a problem. Firefox makes this easy. Simply right-click the webpage and select \u0026lsquo;View-\u0026gt;Page Source.\nThe HTML opens in a separate window. Use its Search feature (Edit=\u0026gt;Find) to search for a keyword to find the HTML for the UI element you\u0026rsquo;re trying to test.\nAlternatively, select just that portion of the webpage for which you want to see the source. Then right-click the webpage and select View Selection Source. In this case, the separate HTML window will contain just a small amount of source, with highlighting on the portion representing your selection.\nLocator Assistance Whenever Selenium-IDE records a locator-type argument, it stores additional information which allows the user to view other possible locator-type arguments that could be used instead. This feature can be very useful for learning more about locators, and is often needed to help one build a different type of locator than the type that was recorded.\nThis locator assistance is presented on the Selenium-IDE window as a drop-down list accessible at the right end of the Target field (only when the Target field contains a recorded locator-type argument).\nBelow is a snapshot showing the contents of this drop-down for one command. Note that the first column of the drop-down provides alternative locators, whereas the second column indicates the type of each alternative.\nWriting a Test Suite A test suite is a collection of test cases which is displayed in the leftmost pane in the IDE.\nThe test suite pane can be manually opened or closed via selecting a small dot halfway down the right edge of the pane (which is the left edge of the entire Selenium-IDE window if the pane is closed).\nThe test suite pane will be automatically opened when an existing test suite is opened or when the user selects the New Test Case item from the File menu. In the latter case, the new test case will appear immediately below the previous test case.\nSelenium-IDE also supports loading pre-existing test cases by using the File -\u0026gt; Add Test Case menu option. This allows you to add existing test cases to a new test suite.\nA test suite file is an HTML file containing a one-column table. Each cell of each row in the  section contains a link to a test case. The example below is of a test suite containing four test cases:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Note: Test case files should not have to be co-located with the test suite file that invokes them. And on Mac OS and Linux systems, that is indeed the case. However, at the time of this writing, a bug prevents Windows users from being able to place the test cases elsewhere than with the test suite that invokes them.\nUser Extensions User extensions are JavaScript files that allow one to create his or her own customizations and features to add additional functionality. Often this is in the form of customized commands although this extensibility is not limited to additional commands.\nThere are a number of useful extensions_ created by users.\nIMPORTANT: THIS SECTION IS OUT OF DATE\u0026ndash;WE WILL BE REVISING THIS SOON.\n _extensions: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  .. _goto_sel_ide.js extension:\nPerhaps the most popular of all Selenium-IDE extensions is one which provides flow control in the form of while loops and primitive conditionals. This extension is the goto_selide.js. For an example of how to use the functionality provided by this extension, look at the page_ created by its author.\nTo install this extension, put the pathname to its location on your computer in the Selenium Core extensions field of Selenium-IDE\u0026rsquo;s Options=\u0026gt;Options=\u0026gt;General tab.\nAfter selecting the OK button, you must close and reopen Selenium-IDE in order for the extensions file to be read. Any change you make to an extension will also require you to close and reopen Selenium-IDE.\nInformation on writing your own extensions can be found near the bottom of the Selenium Reference_ document.\nSometimes it can prove very useful to debug step by step Selenium IDE and your User Extension. The only debugger that appears able to debug XUL/Chrome based extensions is Venkman which is supported in Firefox until version 32 included. The step by step debug has been verified to work with Firefox 32 and Selenium IDE 2.9.0.\nFormat Format, under the Options menu, allows you to select a language for saving and displaying the test case. The default is HTML.\nIf you will be using Selenium-RC to run your test cases, this feature is used to translate your test case into a programming language. Select the language, e.g. Java, PHP, you will be using with Selenium-RC for developing your test programs. Then simply save the test case using File=\u0026gt;Export Test Case As. Your test case will be translated into a series of functions in the language you choose. Essentially, program code supporting your test is generated for you by Selenium-IDE.\nAlso, note that if the generated code does not suit your needs, you can alter it by editing a configuration file which defines the generation process.\nEach supported language has configuration settings which are editable. This is under the Options=\u0026gt;Options=\u0026gt;Formats tab.\nExecuting Selenium-IDE Tests on Different Browsers While Selenium-IDE can only run tests against Firefox, tests developed with Selenium-IDE can be run against other browsers, using a simple command-line interface that invokes the Selenium-RC server. This topic is covered in the :ref:Run Selenese tests \u0026lt;html-suite\u0026gt; section on Selenium-RC chapter. The -htmlSuite command-line option is the particular feature of interest.\nTroubleshooting Below is a list of image/explanation pairs which describe frequent sources of problems with Selenium-IDE:\nTable view is not available with this format.\nThis message can be occasionally displayed in the Table tab when Selenium IDE is launched. The workaround is to close and reopen Selenium IDE. See issue 1008. for more information. If you are able to reproduce this reliably then please provide details so that we can work on a fix.\nerror loading test case: no command found\nYou\u0026rsquo;ve used File=\u0026gt;Open to try to open a test suite file. Use File=\u0026gt;Open Test Suite instead.\nAn enhancement request has been raised to improve this error message. See issue 1010.\nThis type of error may indicate a timing problem, i.e., the element specified by a locator in your command wasn\u0026rsquo;t fully loaded when the command was executed. Try putting a pause 5000 before the command to determine whether the problem is indeed related to timing. If so, investigate using an appropriate waitFor* or *AndWait command before the failing command.\nWhenever your attempt to use variable substitution fails as is the case for the open command above, it indicates that you haven\u0026rsquo;t actually created the variable whose value you\u0026rsquo;re trying to access. This is sometimes due to putting the variable in the Value field when it should be in the Target field or vice versa. In the example above, the two parameters for the store command have been erroneously placed in the reverse order of what is required. For any Selenese command, the first required parameter must go in the Target field, and the second required parameter (if one exists) must go in the Value field.\nerror loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nOne of the test cases in your test suite cannot be found. Make sure that the test case is indeed located where the test suite indicates it is located. Also, make sure that your actual test case files have the .html extension both in their filenames, and in the test suite file where they are referenced.\nAn enhancement request has been raised to improve this error message. See issue 1011.\nYour extension file\u0026rsquo;s contents have not been read by Selenium-IDE. Be sure you have specified the proper pathname to the extensions file via Options=\u0026gt;Options=\u0026gt;General in the Selenium Core extensions field. Also, Selenium-IDE must be restarted after any change to either an extensions file or to the contents of the Selenium Core extensions field.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/mock_external_services/",
	"title": "Mock de servicios externos",
	"tags": [],
	"description": "",
	"content": "Eliminar las dependencias de servicios externos mejorará en gran medida la velocidad y la estabilidad de tus pruebas.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/support_classes/",
	"title": "Clases de apoyo",
	"tags": [],
	"description": "",
	"content": " Las clases de soporte de WebDriver son proporcionadas para simplificar el mantenimiento de tu código. Proporcionan una buena abstracción para modelar mas fácilmente elementos HTML como objetos de dominio, también proporcionando métodos de ayuda para hacer que el uso de tales objetos sea fácil de razonar. Aprenderemos acerca de:\n Estrategias de localizacion Eventos LoadableComponent ThreadGuard etc.  Iniciemos:\nThreadGuard  Esta clase solo esta disponible en la librería de enlace de Java\n ThreadGuard comprueba que se llama a un controlador solo desde el mismo hilo que lo creó. Los problemas de subprocesos, especialmente cuando se ejecutan pruebas en paralelo, pueden tener errores misteriosos y difícil de diagnosticar. El uso de este contenedor evita esta categoría de errores y generará una excepción cuando ocurran.\nEl siguiente ejemplo simula un choque de hilos:\npublic class DriverClash { //El hilo (thread) main (id 1) creó este controlador  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) llama al mismo controlador causando el choque  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } El resultado se muestra a continuación:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour Como puede verse en el ejemplo:\n protectedDriver Será creado en el hilo Main. Utilizamos Java Runnable para iniciar un nuevo proceso y un nuevo Thread para ejecutar el proceso. Ambos Thread chocarán porque el Thread principal no tiene protectedDriver en su memoria. ThreadGuard.protect lanzará una excepción.  Nota: Esto no reemplaza la necesidad de usar ThreadLocal para administrar los controladores cuando se ejecutan en paralelo.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/test_dependency/",
	"title": "Dependencia entre pruebas",
	"tags": [],
	"description": "",
	"content": "Una idea muy común y equivocada sobre la automatización de pruebas es en lo que respecta al orden de los tests. Tus tests deberían ser capaces de ejecutarse sin tener en cuenta el orden y no depender los unos de los otros para poder finalizarse satisfactoriamente.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/improved_reporting/",
	"title": "Mejores reportes",
	"tags": [],
	"description": "",
	"content": "Selenium no está diseñado para informar sobre el estado de los casos de prueba ejecutados. Aprovechando las capacidades de reporte incorporadas en la mayoría de los frameworks de pruebas unitarias es un buen comienzo. La mayoría de los frameworks de pruebas unitarias tienen utilidades que pueden generar reportes con formato xUnit o HTML. Los reportes xUnit son populares para importar resultados a una integración continua (CI) como Jenkins, Travis, Bamboo, etc. Aquí hay algunos enlaces para obtener más información sobre la generación de los reportes para varios lenguajes. NUnit 3 Console Runner\nNUnit 3 Console Command Line\nxUnit getting test results in TeamCity\nxUnit getting test results in CruiseControl.NET\nxUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": " WebDriver WebDriver controla un navegador de forma nativa, como lo haría un usuario, ya sea localmente o en una máquina remota utilizando el servidor Selenium, marca un salto adelante en términos de automatización de navegadores.\nSelenium WebDriver se refiere tanto a los enlaces de lenguajes como también a las implementaciones individuales del código controlador del navegador. Esto se conoce comúnmente solo como WebDriver.\nSelenium WebDriver es una Recomendación W3C\n WebDriver está diseñado como una interfaz de programación simple y más concisa.\n WebDriver es una API compacta orientada a objetos.\n Controla el navegador de manera efectiva.\n  "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "Alertas, avisos y confirmaciones de JavaScript",
	"tags": [],
	"description": "",
	"content": " WebDriver proporciona una API para trabajar con los tres tipos nativos de mensajes emergentes ofrecidos por JavaScript. Estas ventanas emergentes están diseñadas por el navegador y ofrecen personalización limitada.\nAlertas El más simple de estos se conoce como alerta, que muestra unmensaje personalizado y un solo botón que descarta la alerta, etiquetado en la mayoría de los navegadores como OK. También se puede descartar en la mayoría de los navegadores presionando el botón de cerrar, pero esto siempre hará lo mismo que el presionar botón OK. Esto es una alerta de ejemplo.\nWebDriver puede obtener el texto de la ventana emergente y aceptar o descartar estas alertas.\nJava Python C# Ruby JavaScript Kotlin // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); // Espera a que se muestre la alerta y almacenala en una variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); // Almacena el texto de la alerta en una variable String text = alert.getText(); // Presiona el botón OK alert.accept();   # Haz clic en el enlace para activar la alerta driver.find_element_by_link_text(\u0026#34;See an example alert\u0026#34;).click() # Espera a que se muestre la alerta y almacenala en una variable alert = wait.until(expected_conditions.alert_is_present()) # Almacena el texto de la alerta en una variable text = alert.text # Presiona el botón OK alert.accept()   // Haz clic en el enlace para activar la alerta driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); // Espera a que se muestre la alerta y almacenala en una variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); // Almacena el texto de la alerta en una variable string text = alert.Text; // Presiona el botón OK alert.Accept();   # Haz clic en el enlace para activar la aler driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Almacena la referencia de la alertta en una variable alert = driver.switch_to.alert # Almacena el texto de la alerta en una variable alert_text = alert.text # Presiona el botón OK alert.accept   // Haz clic en el enlace para activar la alerta await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Espera a que se muestre la alerta await driver.wait(until.alertIsPresent()); // Almacena la alerta en una variable let alert = await driver.switchTo().alert(); // Almacena el texto de la alerta en una variable let alertText = await alert.getText(); // Presiona el botón OK await alert.accept(); // Nota: Para usar await, el código mostrado arriba debe estar en una función async    // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() // Espera a que se muestre la alerta y almacenala en una variable val alert = wait.until(ExpectedConditions.alertIsPresent()) // Almacena el texto de la alerta en una variable val text = alert.getText() // Presiona el botón OK alert.accept()     Confirm Un cuadro de confirmación es similar a una alerta, excepto que el usuario también puede elegir cancelar el mensaje. Esto es un confirm de ejemplo.\nEste ejemplo también muestra un enfoque diferente para almacenar una alerta:\nJava Python C# Ruby JavaScript Kotlin // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); // Espera a que se muestre la alerta wait.until(ExpectedConditions.alertIsPresent()); // Almacena la alerta en una variable Alert alert = driver.switchTo().alert(); // Almacena la alerta en una variable para poder reusarla String text = alert.getText(); // Presiona el botón cancelar alert.dismiss();   # Haz clic en el enlace para activar la alerta driver.find_element_by_link_text(\u0026#34;See a sample confirm\u0026#34;).click() # Espera a que se muestre la alerta wait.until(expected_conditions.alert_is_present()) # Almacena la alerta en una variable para poder reusarla alert = driver.switch_to.alert # Almacena el texto de la alerta en una variable text = alert.text # Presiona el botón cancelar alert.dismiss()   // Haz clic en el enlace para activar la alerta driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Espera a que se muestre la alerta wait.Until(ExpectedConditions.AlertIsPresent()); // Almacena la alerta en una variable IAlert alert = driver.SwitchTo().Alert(); // Almacena la alerta en una variable para poder reusarla string text = alert.Text; // Presiona el botón cancelar alert.Dismiss();   # Haz clic en el enlace para activar la alerta driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Almacena la referencia de la alertta en una variable alert = driver.switch_to.alert # Almacena el texto de la alerta en una variable alert_text = alert.text # Presiona el botón cancelar alert.dismiss   // Haz clic en el enlace para activar la alerta await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Espera a que se muestre la alerta await driver.wait(until.alertIsPresent()); // Almacena la alerta en una variable let alert = await driver.switchTo().alert(); // Almacena el texto de la alerta en una variable let alertText = await alert.getText(); // Presiona el botón cancelar await alert.dismiss(); // Nota: Para usar await, el código mostrado arriba debe estar en una función async    // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Espera a que se muestre la alerta wait.until(ExpectedConditions.alertIsPresent()) // Almacena la alerta en una variable val alert = driver.switchTo().alert() // Almacena la alerta en una variable para poder reusarla val text = alert.text //Presiona el botón cancelar alert.dismiss()     Prompt Los prompts son similares a los cuadros de confirmación, excepto que también incluyen una entrada de texto. Similar a trabajar con elementos de los formularios, puedes usar el sendKeys de WebDriver para completar una respuesta. Esto reemplazará completamente el texto por defecto. Al presionar el botón cancelar esto hará que no se envie ningún texto. Esto es un prompt de ejemplo.\nJava Python C# Ruby JavaScript Kotlin // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); // Espera a que se muestre la alerta y almacenala en una variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); // Inserta tu mensaje alert.sendKeys(\u0026#34;Selenium\u0026#34;); // Presiona el botón OK alert.accept();   # Haz clic en el enlace para activar la alerta driver.find_element_by_link_text(\u0026#34;See a sample prompt\u0026#34;).click() # Espera a que se muestre la alerta wait.until(expected_conditions.alert_is_present()) # Almacena la alerta en una variable para poder reusarla alert = Alert(driver) # Inserta tu mensaje alert.send_keys(\u0026#34;Selenium\u0026#34;) # Presiona el botón OK alert.accept()   // Haz clic en el enlace para activar la alerta driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); // Espera a que se muestre la alerta y almacenala en una variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); // Inserta tu mensaje alert.SendKeys(\u0026#34;Selenium\u0026#34;); // Presiona el botón OK alert.Accept();   # Haz clic en el enlace para activar la alerta driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Almacena la referencia de la alerta en una variable alert = driver.switch_to.alert # Inserta tu mensaje alert.send_keys(\u0026#34;selenium\u0026#34;) # Presiona el botón OK alert.accept   // Haz clic en el enlace para activar la alerta await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Espera a que se muestre la alerta await driver.wait(until.alertIsPresent()); // Almacena la alerta en una variable let alert = await driver.switchTo().alert(); // Inserta tu mensaje await alert.sendKeys(\u0026#34;Selenium\u0026#34;); // Presiona el botón OK await alert.accept(); // Nota: Para usar await, el código mostrado arriba debe estar en una función async    // Haz clic en el enlace para activar la alerta driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() // Espera a que se muestre la alerta y almacenala en una variable val alert = wait.until(ExpectedConditions.alertIsPresent()) // Inserta tu mensaje alert.sendKeys(\u0026#34;Selenium\u0026#34;) // Presiona el botón OK alert.accept()     "
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "Evitar compartir estados",
	"tags": [],
	"description": "",
	"content": "Aunque se menciona en varios lugares, vale la pena mencionarlo nuevamente. Asegurate de que las pruebas estén aisladas unas de otras.\n No compartas datos de prueba. Imagina varias pruebas en la que cada una consulta a la base de datos para pedidos válidos antes de elegir uno para realizar una acción. Si dos pruebas eligen el mismo pedido es probable que obtengas un comportamiento inesperado.\n Limpia los datos obsoletos en la aplicación que podrían ser recogidos por otra prueba p. ej. registros de pedidos inválidos.\n Crear una nueva instancia de WebDriver por prueba. Esto ayuda a garantizar el aislamiento de la prueba y simplifica la paralelización.\n  "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/performance_testing/",
	"title": "Pruebas de rendimiento",
	"tags": [],
	"description": "",
	"content": "Las pruebas de rendimiento usando Selenium y el WebDriver generalmente no son aconsejables. No porque Selenium sea incapaz de ello si no porque no esta optimizado para ello y es poco probable que se obtengan buenos resultados.\nPuede parecer ideal realizar pruebas de rendimiento desde el contexto de un usuario pero una suite de tests del WebDriver esta sujeta a demasiados puntos fragiles tanto internamente como externamente los cuales están fuera de nuestro control. Por ejemplo, la velocidad de puesta en marcha de los navegadores, la velocidad de los servidores HTTP, las respuestas servidores externos que alojan JavaScript o CSS, y la propia penalización debida a la instrumentación de la propia implementación del WebDriver. Cualquier cambio en alguno de estos puntos causará una variación en los resultados. Es difícil separar la diferencia entre el rendimiento de tu sitio web y el rendimiento de tus recursos externos, y también es difícil de definir el impacto negativo en el rendimiento debido al uso del WebDriver en el navegador especialmente si estas inyectando scripts.\nOtra de las principales atracciones es el \u0026ldquo;ahorrarse tiempo\u0026rdquo; llevando a cabo las pruebas funcionales y de rendimiento al mismo tiempo. Sin embargo los tests funcionales y de rendimiento tienen objetivos totalmente opuestos. A la hora de probar funcionalidades, debemos de ser pacientes y esperar a que finalice la carga esto enturbiará los resultados de las pruebas de rendimiento y viceversa.\nPara mejorar el rendimiento de tu pagina web, necesitarás ser capaz de analizar el rendimiento general, independientemente de las diferencias entre entornos, de identificar malas practicas en el código, de descomponer el rendimiento de de los diferentes recursos (ej. CSS en JavaScript) con el fin de saber donde mejorar. Existen herramientas de pruebas de rendimiento disponibles que ya pueden hacer este trabajo y las cuales pueden proveer de informes y análisis que incluso pueden hacer sugerencias de mejora.\nEste es un ejemplo de un paquete (de código libre) que se puede usar, JMeter.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/working_with_cookies/",
	"title": "Trabajando con las cookies",
	"tags": [],
	"description": "",
	"content": " Una cookie es una pequeña pieza de datos que es enviada desde el sitio web y es almacenada en el ordenador. Las cookies son usadas principalmente para reconocer al usuario y cargar la información almacenada.\nEl API de WebDriver proporciona una forma de interactuar con las cookies a través de métodos incorporados como:\nAñadir una Cookie Este método es usado para añadir una cookie al contexto actual del navegador. Este método solo acepta un conjunto de objetos JSON serializables definidos. En este enlace  esta la lista de claves valor JSON que son aceptadas.\nLo primero de todo, necesitas estar en el dominio para el que la cookie es valida. Si intentas añadir un conjunto de cookies preestablecidas antes de empezar a interactuar con el sitio web y la pagina de inicio es muy pesada o tarda demasiado en cargar una alternativa es encontrar una pagina mas pequeña en el sitio (típicamente la pagina del error 404 es liviana ej. http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Añade una cookie al contexto actual del navegador  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Añade una cookie al contexto actual del navegador driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Añade una cookie al contexto actual del navegador  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Añade una cookie al contexto actual del navegador driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade una cookie al contexto actual del navegador  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Añade una cookie al contexto actual del navegador  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit() } }     Obtener una cookie por nombre Devuelve la información de la cookie serializada que concuerda con el nombre de la cookie entre todas las cookies asociadas.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) # Añade una cookie al contexto actual del navegador driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39; print driver.get_cookie(\u0026#34;foo\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade una cookie en el dominio actual  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Obtiene los detalles de la cookie con el nombre \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); println(cookie); } finally { driver.quit() } }     Obtener todas las cookies Devuelve la información serializada de las cookies de manera satisfactoria para el contexto actual del navegador. Si el navegador no esta disponible devolverá un error.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Añade varias cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Obtiene todas las cookies disponibles  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Obtiene todas las cookies disponibles print driver.get_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Obtiene todas las cookies disponibles  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Obtiene todas las cookies disponibles puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade varias cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Obtiene todas las cookies disponibles  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Obtiene todas las cookies disponibles  val cookies = driver.manage().cookies; println(cookies); } finally { driver.quit() } }     Borrado de una Cookie Borra la información de la cookie que coincida con el nombre de la cookie proporcionado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java tambien proporciona una forma de borrar cookies pasando un objeto cookie del contexto actual del navegador. */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Borra la cookie con el nombre \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .Net tambien proporciona una forma de borrar cookies  // pasando un objeto cookie del contexto actual del navegador.  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Borra la cookie con el nombre \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade varias cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Muestra todas las cookies disponibles  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1); // Borra la cookie con el nombre \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); // Borra una cookie pasando un objeto cookie del contexto actual del navegador.  driver.manage().deleteCookie(cookie1); } finally { driver.quit() } }R     Borra todas las Cookies Borra todas las cookies del contexto actual del navegador.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Borra todas las cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navega a la URL driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Borra todas las cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Borra todas las cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Borra todas las cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade varias cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Borra todas las cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Borra todas las cookies  driver.manage().deleteAllCookies(); } finally { driver.quit() } }     El Atributo Same-Site cookie Este atributo permite al usuario enseñar a los navegadores a controlar que cookies son mandadas junto con las peticiones iniciadas por servicios externos. Esto introducido con la intención de prevenir ataques CSRF (Cross-Site Request Forgery) El atributo Same-Site acepta dos parámetros como instrucciones:\nEstricto: Cuando el atributo sameSite esta fijado como Strict (estricto en español), la cookie no será enviada junto a las peticiones iniciadas por paginas web externas.\nLaxo: Cuando el atributo sameSite se fija como Lax (Laxo en español), la cookie será enviada junto con la petición GET iniciada por paginas web externas.\nNota: Ahora mismo esta característica esta disponible en la versión 80 y superiores de chrome funcionando con Selenium 4 y versiones posteriores.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class cookieTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); Cookie cookie = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build(); Cookie cookie1 = new Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build(); driver.manage().addCookie(cookie); driver.manage().addCookie(cookie1); System.out.println(cookie.getSameSite()); System.out.println(cookie1.getSameSite()); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Añade la cookie en el contexto actual del navegador con el parámetro  # sameSite como \u0026#39;Strict\u0026#39; (o) \u0026#39;Lax\u0026#39; driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Strict\u0026#39;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;, \u0026#39;sameSite\u0026#39;: \u0026#39;Lax\u0026#39;}) cookie1 = driver.get_cookie(\u0026#39;foo\u0026#39;) cookie2 = driver.get_cookie(\u0026#39;foo1\u0026#39;) print cookie1 print cookie2   // No disponemos del ejemplo de código en C# aun - Ayudanos a ello abriendo un PR    require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context with sameSite \u0026#39;Strict\u0026#39; (or) \u0026#39;Lax\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Strict\u0026#34;) driver.manage.add_cookie(name: \u0026#34;foo1\u0026#34;, value: \u0026#34;bar\u0026#34;, same_site: \u0026#34;Lax\u0026#34;) puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) puts driver.manage.cookie_named(\u0026#39;foo1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Añade la cookie en el contexto actual del navegador con el parámetro  // sameSite como \u0026#39;Strict\u0026#39; (o) \u0026#39;Lax\u0026#39;  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Strict\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;, sameSite:\u0026#39;Lax\u0026#39;}); console.log(await driver.manage().getCookie(\u0026#39;key\u0026#39;)); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;http://www.example.com\u0026#34;) val cookie = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Strict\u0026#34;).build() val cookie1 = Cookie.Builder(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;).sameSite(\u0026#34;Lax\u0026#34;).build() driver.manage().addCookie(cookie) driver.manage().addCookie(cookie1) println(cookie.getSameSite()) println(cookie1.getSameSite()) } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/es/remote_webdriver/",
	"title": "WebDriver remoto",
	"tags": [],
	"description": "",
	"content": " WebDriver remoto Puedes usar WebDriver de forma remota de la misma manera que lo usarías localmente. La principal diferencia es que un WebDriver remoto debe ser configurado para que pueda ejecutar tus pruebas en una máquina diferente.\nUn WebDriver remoto se compone de dos piezas: un cliente y un servidor. El cliente es tu prueba de WebDriver y el servidor es simplemente un servlet Java, que se puede alojar en cualquier servidor moderno de aplicaciones JEE.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/",
	"title": "Guías y recomendaciones",
	"tags": [],
	"description": "",
	"content": " Guías y recomendaciones Una nota sobre \u0026ldquo;Mejores prácticas\u0026rdquo;: hemos evitado intencionalmente la frase \u0026ldquo;Mejores Prácticas\u0026rdquo; en esta documentación. Ningún enfoque funciona para todas las situaciones. Preferimos la idea de \u0026ldquo;Directrices y recomendaciones\u0026rdquo;. Te alentamos a leer a través de estos y decidir cuidadosamente cuales enfoques funcionarían para ti en tu entorno particular.\nLas pruebas funcionales son difíciles de realizar por muchas razones. Como si el estado de la aplicación, la complejidad y las dependencias no dificultaran las pruebas, tratar con navegadores (especialmente con incompatibilidades entre navegadores) hace que escribir buenas pruebas sea un desafío.\nSelenium proporciona herramientas para facilitar la interacción funcional del usuario, pero no le ayuda a escribir conjuntos de pruebas bien diseñados. En este capítulo ofrecemos consejos, pautas y recomendaciones sobre cómo abordar la automatización funcional de páginas web.\nEste capítulo registra los patrones de diseño de software populares entre muchos de los usuarios de Selenium que han demostrado tener éxito a lo largo de los años.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/test_independency/",
	"title": "Independencia en las pruebas",
	"tags": [],
	"description": "",
	"content": "Escribe cada prueba como su propia unidad. Escribe las pruebas de una manera que no dependan de otras pruebas para completarse:\nDigamos que hay un sistema de gestión de contenido con el que puedes crear algún contenido personalizado que luego después publicar aparece en tu sitio web como un módulo, y puede llevar algún tiempo sincronizar entre el CMS y y la aplicación.\nUna forma incorrecta de probar tu módulo es que el contenido está creado y publicado en una prueba y luego verificando el módulo en otra prueba. Esta no es factible ya que el contenido puede no estar disponible de inmediato para otra prueba después de la publicación.\nEn cambio, puedes crear un contenido auxiliar que se puede activar y desactivar dentro de la prueba afectada y úsarla para validar el módulo. Sin embargo, para la creación de contenido, aún puedes tener una prueba por separado.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/http_proxies/",
	"title": "Proxies Http",
	"tags": [],
	"description": "",
	"content": "Un servidor proxy actúa como intermediario para solicitudes entre un cliente y un servidor. En forma simple, el tráfico fluye a través del servidor proxy en camino a la dirección solicitada y de regreso.\nUn servidor proxy para scripts de automatización con Selenium podría ser útil para:\n Captura el tráfico de la red Simular llamadas de backend realizadas por el sitio web Accede al sitio web requerido bajo topologías de red complejas o restricciones/políticas corporativas estrictas.  Si te encuentras en un entorno corporativo, y un navegador no puede conectarse a una URL, esto es muy probablemente porque el ambiente necesita un proxy para acceder.\nSelenium WebDriver proporciona una via para configurar el proxy:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.Proxy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.chrome.ChromeOptions; public class proxyTest { public static void main(String[] args) { Proxy proxy = new Proxy(); proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;); ChromeOptions options = new ChromeOptions(); options.setCapability(\u0026#34;proxy\u0026#34;, proxy); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://www.google.com/\u0026#34;); driver.manage().window().maximize(); driver.quit(); } }   from selenium import webdriver PROXY = \u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34; webdriver.DesiredCapabilities.FIREFOX[\u0026#39;proxy\u0026#39;] = { \u0026#34;httpProxy\u0026#34;: PROXY, \u0026#34;ftpProxy\u0026#34;: PROXY, \u0026#34;sslProxy\u0026#34;: PROXY, \u0026#34;proxyType\u0026#34;: \u0026#34;MANUAL\u0026#34;, } with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://selenium.dev\u0026#34;)   // Need pr    # Need PR   // need PR    import org.openqa.selenium.Proxy import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions class proxyTest { fun main() { val proxy = Proxy() proxy.setHttpProxy(\u0026#34;\u0026lt;HOST:PORT\u0026gt;\u0026#34;) val options = ChromeOptions() options.setCapability(\u0026#34;proxy\u0026#34;, proxy) val driver: WebDriver = ChromeDriver(options) driver[\u0026#34;https://www.google.com/\u0026#34;] driver.manage().window().maximize() driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/link_spidering/",
	"title": "Rastreo de enlaces",
	"tags": [],
	"description": "",
	"content": "Usando WebDriver para arañar una web a través de enlaces no es una práctica recomendada, no porque no se pueda hacer, pero porque definitivamente no es la herramienta más ideal. WebDriver necesita tiempo para iniciarse, y puede tomar varios de segundos hasta un minuto dependiendo de cómo se escriba tu prueba, solo para llegar a la página y atravesar el DOM.\nEn lugar de usar WebDriver para esto, podrías ahorrar un montón de tiempo ejecutando un comando curl, o usando una librería como BeautifulSoup ya que estos métodos no se basan en crear un navegador y navegar a una página. Estás ahorrando toneladas de tiempo al no utilizar WebDriver para esta tarea.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Considerar el uso de un API fluída",
	"tags": [],
	"description": "",
	"content": "Martin Fowler acuñó el término \u0026ldquo;API fluido\u0026rdquo;. Selenium ya implementa algo como esto en su clase FluentWait, que se entiende como una alternativa a la clase estándar Wait. Puedes habilitar el patrón de diseño Fluent API en tu objeto de página y luego consulta la página de búsqueda de Google con un fragmento de código como este:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); La clase de objeto de página de Google con este comportamiento fluido podría verse así:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // Si load() falla, se llama a isLoaded() hasta que la página termine de cargarse  PageFactory.initElements(driver, this); // Inicializa los WebElements en la pagina  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } }"
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/page_loading_strategy/",
	"title": "Estrategia de carga de página",
	"tags": [],
	"description": "",
	"content": " Define la estrategia de carga de la página en la sesión actual. Por defecto, cuando Selenium WebDriver carga una página, sigue la pageLoadStrategy normal. Siempre se recomienda detener la descarga de más recursos adicionales (como imágenes, css, js) cuando la carga de la página lleva mucho tiempo.\nLa propiedad document.readyState de un documento describe el estado de carga del documento actual. Por defecto, WebDriver esperará responder a una llamada driver.get() (o) driver.navigate().to() hasta que el estado de documento listo esté completo\nEn aplicaciones SPA (como Angular, react, Ember) una vez que el contenido dinámico ya está cargado (es decir, una vez que el estado de pageLoadStrategy es COMPLETO), hacer clic en un enlace o realizar alguna acción dentro de la página no hará una nueva solicitud al servidor ya que el contenido se carga dinámicamente en el lado del cliente sin una actualización de la página.\nLas aplicaciones de SPA pueden cargar muchas vistas dinámicamente sin ninguna solicitud del servidor, por lo que pageLoadStrategy siempre mostrará el estado \u0026lsquo;COMPLETO\u0026rsquo; hasta que hagamos un nuevo driver.get() y driver.naviagte().to()\nWebDriver pageLoadStrategy permite los siguientes valores:\nnormal Esto hará que Selenium WebDriver espere a que se cargue toda la página. Cuando se establece en normal, Selenium WebDriver espera hasta que se dispare el evento load y sea retornado.\nPor defecto normal se establece en el navegador si no se proporciona ninguno.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;normal\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Normal; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager Esto hará que Selenium WebDriver espere hasta que el documento HTML inicial se haya cargado y analizado por completo, y descarta la carga de hojas de estilo, imágenes y sub marcos.\nCuando se establece en eager, Selenium WebDriver espera hasta que se dispare el evento DOMContentLoaded y sea retornado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;eager\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.Eager; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none Cuando se establece en none Selenium WebDriver solo espera hasta que se descargue la página inicial.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() options.page_load_strategy = \u0026#39;none\u0026#39; driver = webdriver.Chrome(options=options) # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace pageLoadStrategy { class pageLoadStrategy { public static void Main(string[] args) { var chromeOptions = new ChromeOptions(); chromeOptions.PageLoadStrategy = PageLoadStrategy.None; IWebDriver driver = new ChromeDriver(chromeOptions); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/es/worst_practices/",
	"title": "Malas prácticas",
	"tags": [],
	"description": "",
	"content": " Malas prácticas "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/web_element/",
	"title": "Elemento web",
	"tags": [],
	"description": "",
	"content": " WebElement representa un elemento del DOM. Los WebElements se pueden encontrar buscando desde la raíz del documento utilizando una instancia de WebDriver o buscando en otra WebElement.\nEl API WebDriver proporciona métodos integrados para encontrar los elementos web que son basados en diferentes propiedades como ID, Nombre, Clase, XPath, Selectores CSS, Texto de enlace, etc.\nFind Element Se utiliza para encontrar un elemento y devuelve la primera referencia única de WebElement que coincide, que puede usarse para acciones futuras con el elemento\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   driver = Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element search_box = driver.find_element_by_name(\u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la URL driver.get \u0026#39;https://google.com\u0026#39; # Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Ejecuta una acción utilizando WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ // Navega a la URL await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); // Ejecuta una acción utilizando WebElemen await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Obtén el elemento cuadro de búsqueda del webElement \u0026#39;q\u0026#39; utilizando Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements Similar a \u0026lsquo;Find Element\u0026rsquo;, pero devuelve una lista de elementos web coincidentes. Para usar un WebElement particular de la lista, debes recorrerla lista de elementos para realizar acciones con el elemento seleccionado.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Firefox() # Navega a la Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39; elements = driver.find_elements_by_tag_name(\u0026#39;p\u0026#39;) for e in elements: print e.text   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navega a la Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la Url driver.get \u0026#39;https://www.example.com\u0026#39; # Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navega a la URL  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.tagName(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Find Element desde Element Se utiliza para encontrar un elemento hijo dentro del contexto del elemento padre. Para lograr esto, el WebElement primario se encadena con \u0026lsquo;findElement\u0026rsquo; para acceder a elementos secundarios.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   driver = Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element_by_tag_name(\u0026#34;form\u0026#34;) search_box = search_form.find_element_by_name(\u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navega a la URL driver.get \u0026#39;https://google.com\u0026#39; # Obtén y almacena el elemento DOM `\u0026lt;form\u0026gt;` search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Obtén el elemento de caja de búsqueda del elemento `form` search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Ejecuta una acción usando WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navega a la URL await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Obtén y alamacena el elemento DOM `\u0026lt;form\u0026gt;` let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Obtén el elemento de caja de búsqueda del elemento `form` let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Ejecuta una acción usando WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements desde Element Se utiliza para encontrar una lista de elementos hijos dentro del contexto del elemento padre. Para lograr esto, el WebElement primario se encadena con \u0026lsquo;findElements\u0026rsquo;para acceder a elementos secundarios.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39; element = driver.find_element_by_tag_name(\u0026#39;div\u0026#39;) # Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39; elements = element.find_elements_by_tag_name(\u0026#39;p\u0026#39;) for e in elements: print e.text   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navega a la URL driver.get \u0026#39;https://www.example.com\u0026#39; # Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  let element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  let elements = await element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Obten el elemento con el nombre de etiqueta \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Obtén todos los elementos con el nombre de etiqueta \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Active Element Se utiliza para rastrear (o) encontrar el elemento DOM que tiene el foco en el contexto de navegación actual.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Obtener el atributo del elemento activo actual  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element_by_css_selector(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Obtener el atributo del elemento activo actual attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print attr   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navega a la URL  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Obtener el atributo del elemento activo actual  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Obtener el atributo del elemento activo actual attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Obtener el atributo del elemento activo actual  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Obtener el atributo del elemento activo actual  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); print(attr); } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/es/grid/",
	"title": "Grid",
	"tags": [],
	"description": "",
	"content": " Grid Selenium Grid es un servidor inteligente que efectúa de proxy que permite a los tests de Selenium enrutar sus comandos hacia instancias remotas de navegadores web. La intención de esto es proporcionar una forma sencilla de ejecutar los tests en paralelo en múltiple maquinas.\nCon Selenium Grid un servidor actúa como el centro de actividad (hub) encargado de enrutar los comandos de los tests en formato JSON hacia uno o mas nodos registrados en el Grid. Los tests contactan con el hub para obtener acceso a las instancias remotas de los navegadores.\nSelenium Grid te permite ejecutar los tests en paralelo en múltiples maquinas y también te permite gestionar diferentes versiones de navegadores y diferentes configuraciones de navegadores de manera centralizada (en lugar de hacerlo de manera individual en cada test)\nSelenium Grid no es una solución mágica para todos tus problemas. Permite resolver un subconjunto de problemas comunes de delegación y distribución, pero, por ejemplo, no administrará su infraestructura y podría no satisfacer sus necesidades personales.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "Nueva instancia del navegador por prueba",
	"tags": [],
	"description": "",
	"content": "Comienza cada prueba desde un estado limpio conocido. Idealmente, ejecuta una nueva máquina virtual para cada prueba. Si ejecutar una nueva máquina virtual no es práctico, al menos inicia un nuevo WebDriver para cada prueba. Para Firefox, inicia un WebDriver con su perfil conocido.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile);"
},
{
	"uri": "https://selenium.dev/documentation/es/driver_idiosyncrasies/",
	"title": "Comportamientos del controlador",
	"tags": [],
	"description": "",
	"content": " Comportamientos del controlador "
},
{
	"uri": "https://selenium.dev/documentation/es/webdriver/keyboard/",
	"title": "Teclado",
	"tags": [],
	"description": "",
	"content": " Keyboard representa un evento del teclado. Las acciones del teclado se realizan mediante el uso de una interfaz de bajo nivel que nos permite proporcionar entradas de un dispositivo virtualizado al navegador web.\nsendKeys El sendKeys escribe una secuencia de teclas en el elemento del DOM incluso si se encuentra una secuencia de teclas modificadoras. Here are the list of possible keystrokes that WebDriver Supports.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;q\u0026#34; y ejecuta la accion del teclado \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34;+Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Inserta el texto \u0026#34;q\u0026#34; y ejecuta la accion del teclado \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown KeyDown se usa para simular la acción de presionar una tecla modificadora (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34;+Keys.ENTER)\r# Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Inserta el texto \u0026#34;Webdriver\u0026#34; y ejecuta la accion del teclado \u0026#34;ENTER\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Ejecuta la acción ctrl + A (modificador CONTROL + Alfabeto A) para seleccionar la página\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp KeyUp se usa para simular la acción de liberar (o) desbloqueo de una tecla modificadora (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Almacena el WebElement del cuadro de búsqueda de Google  WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)  action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Almacena el WebElement del cuadro de búsqueda de Google  search = driver.find_element_by_name(\u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Almacena el WebElement del cuadro de búsqueda de Google  IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Almacena el WebElement del cuadro de búsqueda de Google  search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Almacena el WebElement del cuadro de búsqueda de Google  let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Almacena el WebElement del cuadro de búsqueda de Google  val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Ingresa el texto \u0026#34;qwerty\u0026#34; con keyDown en la tecla SHIFT y después de keyUp a la tecla SHIFT (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  clear Borra el contenido de un elemento editable. Esto solo se aplica a los elementos que son editables e interactuables, de lo contrario, Selenium devuelve el error (invalid element state (or) Element not interactable)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Borra el texto ingresado\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rdriver = webdriver.Chrome()\r# Navega a la URL\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Almacena el elemento \u0026#39;SearchInput\u0026#39;\r SearchInput = driver.find_element_by_name(\u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Borra el texto ingresado\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navega a la URL\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Borra el texto ingresado\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navega a la URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Almacena el elemento \u0026#39;SearchInput\u0026#39;t\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Borra el texto ingresado\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navega a la URL\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Borra el texto ingresado\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navega a la URL\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Almacena el elemento \u0026#39;SearchInput\u0026#39;\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Borra el texto ingresado\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "
},
{
	"uri": "https://selenium.dev/documentation/es/support_packages/",
	"title": "Paquetes de soporte",
	"tags": [],
	"description": "",
	"content": " Paquetes de soporte "
},
{
	"uri": "https://selenium.dev/documentation/es/legacy_docs/",
	"title": "Legacy",
	"tags": [],
	"description": "",
	"content": " Legacy En esta sección, puede encontrar toda la documentación relacionada con los componentes legacy (heredados) de Selenium. Esto está destinado a mantenerse únicamente por razones históricas y no como un incentivo para usar componentes en desuso.\n"
},
{
	"uri": "https://selenium.dev/documentation/es/front_matter/",
	"title": "Texto preliminar",
	"tags": [],
	"description": "",
	"content": " Texto preliminar "
},
{
	"uri": "https://selenium.dev/documentation/es/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://selenium.dev/documentation/es/contributing/",
	"title": "Contributing to the Selenium Site &amp; Documentation",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to Spanish. Do you speak Spanish? Help us to translate it by sending us pull requests!\n Selenium is a big software project, its site and documentation are key to understanding how things work and learning effective ways to exploit its potential.\nThis project contains both Selenium\u0026rsquo;s site and documentation. This is an ongoing effort (not targeted at any specific release) to provide updated information on how to use Selenium effectively, how to get involved and how to contribute to Selenium.\nContributions toward the site and docs follow the process described in the below section about contributions. You should spend some time familiarising yourself with the documentation by reading more about it.\nThe Selenium project welcomes contributions from everyone. There are a number of ways you can help:\nReport an issue When reporting a new issues or commenting on existing issues please make sure discussions are related to concrete technical issues with the Selenium software, its site and/or documentation.\nAll of the Selenium components change quite fast over time, so this might cause the documentation to be out of date. If you find this to be the case, as mentioned, don\u0026rsquo;t doubt to create an issue for that. It also might be possible that you know how to bring up to date the documentation, so please send us a pull request with the related changes.\nIf you are not sure about what you have found is an issue or not, please ask through the communication channels described at https://selenium.dev/support.\nContributions The Selenium project welcomes new contributors. Individuals making significant and valuable contributions over time are made Committers and given commit-access to the project.\nThis guide will guide you through the contribution process.\nStep 1: Fork Fork the project on Github and check out your copy locally.\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io Dependencies: Hugo We use Hugo to build and render the site and docs. To verify everything locally before even committing any changes, please install Hugo, get familiar with it and run the local server to render the site locally (detailed instructions can be found in the next steps).\nStep 2: Branch Create a feature branch and start hacking:\n% git checkout -b my-feature-branch We practice HEAD-based development, which means all changes are applied directly on top of master.\nStep 3: Make changes The repository contains the site and docs, which are two separate Hugo projects. If you want to make changes to the site, work on the site_source_files directory. To see a live preview of your changes, run hugo server on the site\u0026rsquo;s root directory.\n% cd site_source_files % hugo server To make changes to the docs, switch to the docs_source_files directory.\n% cd docs_source_files % hugo server The docs are translated into several languages, and translations are based on the English content. When you are changing a file, be sure to make your changes in all the other translated files as well. This might differ depending on the change, for example:\n If you add a code example to the browser_manipulation.en.md file, also add it to browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md, and all other translated files. If you find a translation that can be improved, only change the translated file. If you are adding a new language translation, add the new files with the appropriate suffix. There is no need to have everything translated to submit a PR, it can be done iteratively. Don\u0026rsquo;t forget to check some needed configuration values in the config.toml file. If you make text changes in the English version, replace the same section in the translated files with your change (yes, in English), and add the following notice at the top of the file.\n{{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}}  Step 4: Commit First make sure git knows your name and email address:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Writing good commit messages is important. A commit message should describe what changed, why, and reference issues fixed (if any). Follow these guidelines when writing one:\n The first line should be around 50 characters or less and contain a short description of the change. Keep the second line blank. Wrap all other lines at 72 columns. Include Fixes #N, where N is the issue number the commit fixes, if any.  A good commit message can look like this:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 The first line must be meaningful as it\u0026rsquo;s what people see when they run git shortlog or git log --oneline.\nStep 5: Rebase Use git rebase (not git merge) to sync your work from time to time.\n% git fetch upstream % git rebase upstream/master Step 6: Test Always remember to run the local server, with this you can be safe that your changes have not broken anything.\nStep 7: Push % git push origin my-feature-branch Go to https://github.com/yourusername/seleniumhq.github.io.git and press the Pull Request and fill out the form. Please indicate that you\u0026rsquo;ve signed the CLA (see Step 7).\nPull requests are usually reviewed within a few days. If there are comments to address, apply your changes in new commits (preferably fixups) and push to the same branch.\nStep 8: Integration When code review is complete, a committer will take your PR and integrate it on the repository\u0026rsquo;s master branch. Because we like to keep a linear history on the master branch, we will normally squash and rebase your branch history.\nCommunication All details on how to communicate with the project contributors and the community overall can be found at https://selenium.dev/support\n"
},
{
	"uri": "https://selenium.dev/documentation/es/",
	"title": "Selenium, el proyecto para automatizar navegadores",
	"tags": [],
	"description": "",
	"content": " Selenium, el proyecto para automatizar navegadores Selenium es un proyecto que alberga un abanico de herramientas y librerías que permiten y apoyan la automatización de navegadores web.\nProporciona extensiones que permiten emular las interacciones que realizan los usuarios con los navegadores, un servidor que permite distribuir la asignación de navegadores de forma escalable, y la infraestructura necesaria para las implementaciones de la especificación del WebDriver del W3C, el cual permite escribir código intercambiable para los navegadores web mas usados.\nEste proyecto es posible gracias a los colaboradores voluntarios, los cuales han dedicado miles de horas de su propio tiempo haciendo así que el código fuente esté disponible de manera gratuita para que cualquiera pueda usarlo, disfrutarlo y mejorarlo.\nSelenium conecta a proveedores de navegadores web, ingenieros y entusiastas para promover un debate abierto sobre la automatización de plataformas web. El proyecto organiza una conferencia anual con el fin de enseñar y nutrir a la comunidad.\nEl corazón de Selenium es el WebDriver, una interfaz que permite escribir conjuntos de instrucciones que se pueden ejecutar de manera indistinta en muchos navegadores.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #Este ejemplo necesita una versión de Selenium WebDriver igual o mayor a la 3.13 with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;))) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Añade el texto \u0026#34;cheese\u0026#34; y efectúa la acción de la tecla \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     Puedes ver este tour rápido para una explicación completa de lo que sucede entre bastidores cuando se ejecuta el código. Es recomendable continuar con el planteamiento que ofrece esta documentación para entender como se puede instalar y usar correctamente Selenium como herramienta de automatización de pruebas, y como se puede escalar pruebas simples como el ejemplo anterior, en grandes entornos con múltiples navegadores en diferentes sistemas operativos.\nEmpezando Si eres nuevo con Selenium, tenemos una serie de recursos que te pueden ayudar a ponerte al día de inmediato\n Tour rápido  WebDriver IDE Grid   "
},
{
	"uri": "https://selenium.dev/documentation/es/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]